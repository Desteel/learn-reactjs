<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/core/hooks/effect-hook" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>
<%@taglib prefix="ad" tagdir="/WEB-INF/tags/application/advertising" %>

<c:url var="corsUrl" value="https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes"/>
<c:url var="httpHeaderUrl" value="/resources/imges/pages/introduction/installation/http_header.png"/>
<c:url var="errorHandlingUrl" value="/updates/error-handling-in-react-16"/>

<a name="pageStart"></a>
<div class="black-line"></div>
<div class="page state-hook-page">
    <h1>3.12.4 Хук эффекта</h1>
    
    <br/>
    
    <p class="introduction">
        Хуки доступны в версии <b>React 16.8</b>. С помощью них можно использовать состояние и другие
        функции React, чтобы не писать класс.
    </p>
    
    <br/>
    
    <p>
        Побочные эффекты можно выполнять в компонентах-функцях используя хука эффекта:
    </p>
    
    <ce:code-example-1/>
    
    <c:url var="stateHookUrl" value="/state-hook"/>
    
    <p>
        Этот фрагмент кода основан на примере счетчика <b><a href="${stateHookUrl}">из предыдущего раздела</a></b>.
        Однако мы добавили в него новую функцию: мы устанавливаем название документа,
        содержащее колличество нажатий.
    </p>
    
    <p>
        Извлечение данных, настройка подписки и ручное изменение DOM в компонентах React -
        все это примеры <b>побочных эффектов</b>. Возможно, вы выполняли такие действия в своих
        компонентах, не зная, вероятно, что они так называются.
    </p>
    
    <app:alert title="Внимание!" type="warning">
        Если вы знакомы с методами ЖЦ компонента-класса, вы можете представлять
        себе хук <code>useEffect</code> как комбинацию <code>componentDidMount</code>, <code>componentDidUpdate</code>
        и <code>componentWillUnmount</code>.
    </app:alert>
    
    <p>
        Компоненты React имеют два основных вида побочных эффектов: требующие
        очистки, и не требующие. Давайте разберём это различие более подробно.
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>3.12.4.1 Эффекты, не требующие очистки</h2>
    <br/>
    
    <p>
        Иногда мы хотим выполнить дополнительный код после того, как React обновил DOM.
        Сетевые запросы, ручные мутации DOM и логирование - типичные примеры эффектов,
        которые не требуют очистки. Мы можем выполнить какой-либо из них и забыть об этом.
        Давайте сравним, как классы и хуки позволяют нам производить такие побочные эффекты.
    </p>
    
    <br/>
    <h3>3.12.4.1.1 Пример с использованием класса</h3>
    <br/>
    
    <p>
        В компонентах-классах React метод <code>render</code> не должен выполнять побочных
        эффектов - слишком рано. Наши эффекты следует выполнять <b>после</b> того,
        как React обновит DOM.
    </p>
    
    <p>
        Вот почему в классах React мы помещаем побочные эффекты в методы
        <code>componentDidMount</code> и <code>componentDidUpdate</code>. Теперь вернёмся к нашему примеру.
        У нас есть компонент-класс со счётчиком, который обновляет название документа
        сразу же после того, как React изменяет DOM:
    </p>
    
    <ce:code-example-2/>
    
    <p>
        Заметьте, как <b>в классе нам приходится дублировать код в этих двух методах ЖЦ</b>.
    </p>
    
    <p>
        Так происходит потому, что нам обычно нужно выполнить один и тот же
        побочный эффект независимо от того, был ли компонент монтирован или обновлен.
        Концептуально, мы хотим, чтобы это происходило после каждой отрисовки, но у
        классов нет такого метода. Мы могли бы вынести код в отдельный метод, но нам
        все равно пришлось бы вызывать его в двух местах.
    </p>
    
    <p>
        Давайте посмотрим, как можно сделать то же самое с хуком <code>useEffect</code>.
    </p>
    
    <br/>
    <h3>3.12.4.1.2 Пример с использованием хука</h3>
    <br/>
    
    <p>Мы уже видели этот пример выше. Давайте рассмотрим его более подробно:</p>
    
    <ce:code-example-3/>
    
    <p>
        <b>Что делает useEffect?</b> Используя этот хук, вы сообщаете React, что
        ваш компонент должен что-то делать после отрисовки. React запомнит
        переданную вами функцию (мы будем называть ее «эффектом») и вызовет
        ее после обновления DOM. В нашем случае мы устанавливаем название документа.
        Кроме этого мы можем извлекать данные или вызывать любой другой императивный API.
    </p>
    
    <p>
        <b>Почему useEffect вызывается внутри компонента?</b> Вызывая <code>useEffect</code>
        внутри компонента, мы получаем доступ к переменной <code>count</code> состояния счетчика
        (или любым другим свойствам) прямо из эффекта. Нам не нужен специальный API
        для её чтения - она уже находится в области видимости функции. Хуки охватывают
        JavaScript-замыкания. Это позволяет обойтись без специального React API:
        сам JavaScript предоставляет решение.
    </p>
    
    <p>
        <b>Запускается ли useEffect после каждой отрисовки?</b> Да! По умолчанию он запускается
        как после первой отрисовки, так и после каждого последующего обновления. (Позже мы
        поговорим о том, как это можно кастомизировать.) Вместо того, чтобы мыслить в терминах
        «монтирования» и «обновления», можно просто представлять, что эффекты
        происходят «после отрисовки». React гарантирует, что DOM будет обновлен к
        моменту запуска эффектов.
    </p>

    <br/>
    <h3>3.12.4.1.3 Детальный разбор</h3>
    <br/>

    <p>Узнав больше об эффектах, этот код становится понятней:</p>

    <ce:code-example-4/>

    <p>
        Сначала мы объявляем переменную состояния <code>count</code>, а затем говорим React,
        что нам нужно использовать эффект. Мы передаем функцию, которая и является нашим
        эффектом, в хук <code>useEffect</code>. Внутри эффекта устанавливаем название документа с помощью
        API браузера <code>document.title</code>. Мы  можем прочитать последнее значение счетчика внутри эффекта,
        потому что он находится в области видимости нашей функции. Когда React отрисовывает
        компонент, он помнит переданный нами эффект, а затем запускает его после обновления DOM.
        Это происходит после каждой отрисовки компонента, включая самую первую.
    </p>

    <p>
        Опытные разработчики JavaScript могут заметить, что функция, переданная хуку <code>useEffect</code>,
        будет отличаться для каждой отрисовки. Так и было задумано. Фактически, это то, что позволяет
        нам считывать значение <code>count</code> внутри эффекта, не беспокоясь о том, что оно устарело. <b>Каждый раз,
        когда компонент перерисовывается, мы планируем новый эффект, заменяя предыдущий</b>. Используя
        такой подход, можно сказать, что в определённом смысле поведение эффектов - это часть
        результата отрисовки: каждый эффект «принадлежит/относится к» определенной отрисовке.
        Позднее станет понятней, почему это полезно.
    </p>

    <app:alert title="Подсказка!" type="success">
        В отличие от <code>componentDidMount</code> или <code>componentDidUpdate</code>, эффекты,
        запланированные с помощью <code>useEffect</code>, не блокируют браузер для обновления экрана.
        Это делает ваше приложение более отзывчивым. Большинству эффектов нет нужды происходить синхронно.
        Но для таких редких случаев (например, нужно получить размеры элемента)
        существует отдельный хук <code>useLayoutEffect</code> с таким же API, как и у хука <code>useEffect</code>.
    </app:alert>

    <p></p>
    <p></p>
    <p></p>
    <p></p>

    <%-- <c:url var="Url" value=""/> --%>
    
    <%--
    <ul>
        <li>
            <p>

            </p>
        </li>
    </ul>
    --%>
    <%-- <app:alert title="Подсказка!" type="success"></app:alert> --%>
    <%-- <app:alert title="Внимание!" type="warning"></app:alert> --%>
    <%-- <code></code> --%>
    <%-- <b></b> --%>
    <%-- <code>&lt; &gt;</code> --%>
    <%-- <b><a href="${}"></a></b> --%>
    <%-- <b><a href="#"></a></b> --%>
    <%-- <a href="#"></a> --%>

</div>

<c:url var="prevPageUrl" value="/core/hooks/glance"/>

<app:page-navigate
    pageStartAncor="pageStart"
    prevPageUrl="${prevPageUrl}"
/>