<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/core/hooks/effect-hook" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>
<%@taglib prefix="ad" tagdir="/WEB-INF/tags/application/advertising" %>

<c:url var="corsUrl" value="https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes"/>
<c:url var="httpHeaderUrl" value="/resources/imges/pages/introduction/installation/http_header.png"/>
<c:url var="errorHandlingUrl" value="/updates/error-handling-in-react-16"/>

<a name="pageStart"></a>
<div class="black-line"></div>
<div class="page state-hook-page">
    <h1>3.12.4 Хук эффекта</h1>
    
    <br/>
    
    <p class="introduction">
        Хуки доступны в версии <b>React 16.8</b>. С помощью них можно использовать состояние и другие
        функции React, чтобы не писать класс.
    </p>
    
    <br/>
    
    <p>
        Побочные эффекты можно выполнять в компонентах-функциях используя хука эффекта:
    </p>
    
    <ce:code-example-1/>
    
    <c:url var="stateHookUrl" value="/core/hooks/state-hook"/>
    
    <p>
        Этот фрагмент кода основан на примере счетчика <b><a href="${stateHookUrl}">из предыдущего раздела</a></b>.
        Однако мы добавили в него новую функцию: мы устанавливаем название документа,
        содержащее колличество нажатий.
    </p>
    
    <p>
        Извлечение данных, настройка подписки и ручное изменение DOM в компонентах React -
        все это примеры <b>побочных эффектов</b>. Возможно, вы выполняли такие действия в своих
        компонентах, не зная, вероятно, что они так называются.
    </p>
    
    <app:alert title="Внимание!" type="warning">
        Если вы знакомы с методами ЖЦ компонента-класса, вы можете представлять
        себе хук <code>useEffect</code> как комбинацию <code>componentDidMount</code>, <code>componentDidUpdate</code>
        и <code>componentWillUnmount</code>.
    </app:alert>
    
    <p>
        Компоненты React имеют два основных вида побочных эффектов: требующие
        очистки, и не требующие. Давайте разберём это различие более подробно.
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>3.12.4.1 Эффекты, не требующие очистки</h2>
    <br/>
    
    <p>
        Иногда мы хотим выполнить дополнительный код после того, как React обновил DOM.
        Сетевые запросы, ручные мутации DOM и логирование - типичные примеры эффектов,
        которые не требуют очистки. Мы можем выполнить какой-либо из них и забыть об этом.
        Давайте сравним, как классы и хуки позволяют нам производить такие побочные эффекты.
    </p>

    <ad:ad-content-banner-1/>
    
    <br/>
    <h3>3.12.4.1.1 Пример с использованием класса</h3>
    <br/>
    
    <p>
        В компонентах-классах React метод <code>render</code> не должен выполнять побочных
        эффектов - слишком рано. Наши эффекты следует выполнять <b>после</b> того,
        как React обновит DOM.
    </p>
    
    <p>
        Вот почему в классах React мы помещаем побочные эффекты в методы
        <code>componentDidMount</code> и <code>componentDidUpdate</code>. Теперь вернёмся к нашему примеру.
        У нас есть компонент-класс со счётчиком, который обновляет название документа
        сразу же после того, как React изменяет DOM:
    </p>
    
    <ce:code-example-2/>
    
    <p>
        Заметьте, как <b>в классе нам приходится дублировать код в этих двух методах ЖЦ</b>.
    </p>
    
    <p>
        Так происходит потому, что нам обычно нужно выполнить один и тот же
        побочный эффект независимо от того, был ли компонент монтирован или обновлен.
        Концептуально, мы хотим, чтобы это происходило после каждой отрисовки, но у
        классов нет такого метода. Мы могли бы вынести код в отдельный метод, но нам
        все равно пришлось бы вызывать его в двух местах.
    </p>
    
    <p>
        Давайте посмотрим, как можно сделать то же самое с хуком <code>useEffect</code>.
    </p>
    
    <br/>
    <h3>3.12.4.1.2 Пример с использованием хука</h3>
    <br/>
    
    <p>Мы уже видели этот пример выше. Давайте рассмотрим его более подробно:</p>
    
    <ce:code-example-3/>
    
    <p>
        <b>Что делает useEffect?</b> Используя этот хук, вы сообщаете React, что
        ваш компонент должен что-то делать после отрисовки. React запомнит
        переданную вами функцию (мы будем называть ее «эффектом») и вызовет
        ее после обновления DOM. В нашем случае мы устанавливаем название документа.
        Кроме этого мы можем извлекать данные или вызывать любой другой императивный API.
    </p>
    
    <p>
        <b>Почему useEffect вызывается внутри компонента?</b> Вызывая <code>useEffect</code>
        внутри компонента, мы получаем доступ к переменной <code>count</code> состояния счетчика
        (или любым другим свойствам) прямо из эффекта. Нам не нужен специальный API
        для её чтения - она уже находится в области видимости функции. Хуки охватывают
        JavaScript-замыкания. Это позволяет обойтись без специального React API:
        сам JavaScript предоставляет решение.
    </p>
    
    <p>
        <b>Запускается ли useEffect после каждой отрисовки?</b> Да! По умолчанию он запускается
        как после первой отрисовки, так и после каждого последующего обновления. (Позже мы
        поговорим о том, как это можно кастомизировать.) Вместо того, чтобы мыслить в терминах
        «монтирования» и «обновления», можно просто представлять, что эффекты
        происходят «после отрисовки». React гарантирует, что DOM будет обновлен к
        моменту запуска эффектов.
    </p>

    <br/>
    <h3>3.12.4.1.3 Детальный разбор</h3>
    <br/>

    <p>Узнав больше об эффектах, этот код становится понятней:</p>

    <ce:code-example-4/>

    <p>
        Сначала мы объявляем переменную состояния <code>count</code>, а затем говорим React,
        что нам нужно использовать эффект. Мы передаем функцию, которая и является нашим
        эффектом, в хук <code>useEffect</code>. Внутри эффекта устанавливаем название документа с помощью
        API браузера <code>document.title</code>. Мы  можем прочитать последнее значение счетчика внутри эффекта,
        потому что он находится в области видимости нашей функции. Когда React отрисовывает
        компонент, он помнит переданный нами эффект, а затем запускает его после обновления DOM.
        Это происходит после каждой отрисовки компонента, включая самую первую.
    </p>

    <ad:ad-content-banner-2/>

    <p>
        Опытные разработчики JavaScript могут заметить, что функция, переданная хуку <code>useEffect</code>,
        будет отличаться для каждой отрисовки. Так и было задумано. Фактически, это то, что позволяет
        нам считывать значение <code>count</code> внутри эффекта, не беспокоясь о том, что оно устарело. <b>Каждый раз,
        когда компонент перерисовывается, мы планируем новый эффект, заменяя предыдущий</b>. Используя
        такой подход, можно сказать, что в определённом смысле поведение эффектов - это часть
        результата отрисовки: каждый эффект «принадлежит/относится к» определенной отрисовке.
        Позднее станет понятней, почему это полезно.
    </p>

    <app:alert title="Подсказка!" type="success">
        В отличие от <code>componentDidMount</code> или <code>componentDidUpdate</code>, эффекты,
        запланированные с помощью <code>useEffect</code>, не блокируют браузер, чтобы обновить экран.
        Таким образом приложение становится более отзывчивым. Большинство эффектов не обязаны происходить синхронно.
        Но для таких редких случаев (например, нужно получить размеры элемента)
        существует отдельный хук <code>useLayoutEffect</code> с таким же API, как и у хука <code>useEffect</code>.
    </app:alert>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>3.12.4.2 Эффекты с очисткой</h2>
    <br/>

    <p>
        Ранее мы рассмотрели, как создавать побочные эффекты, которые не требуют
        какой-либо очистки. Однако некоторым эффектам она всё же нужна. Допустим,
        нам нужно настроить <b>подписку на некоторый внешний источник данных</b>. В этом
        случае важно провести очистку, чтобы избежать утечек памяти! Давайте сравним,
        как мы можем выполнить очистку в классах и с использованием хуков.
    </p>

    <br/>
    <h3>3.12.4.2.1 Пример с использованием класса</h3>
    <br/>

    <p>
        В классе React вы обычно устанавливаете подписку в методе ЖЦ <code>componentDidMount</code> и
        очищаете ее в методе <code>componentWillUnmount</code>. Допустим, у нас есть модуль <code>ChatAPI</code>,
        который позволяет подписаться на онлайн-статус друга. Вот как мы можем подписаться
        и отобразить этот статус с помощью класса:
    </p>

    <ce:code-example-5/>

    <p>
        Обратите внимание, что <code>componentDidMount</code> и <code>componentWillUnmount</code> должны быть
        зеркальны друг другу. Методы ЖЦ заставляют нас размещать коды подписки и отписки по разным местам, хотя
        концептуально код в обоих частях этой логики связан с одним и тем же эффектом.
    </p>

    <app:alert title="Внимание!" type="warning">
        Внимательные читатели могут заметить, что для полной корректности этот пример
        нуждается также и в методе <code>componentDidUpdate</code>. Пока проигнорируем этот момент,
        но вернемся к нему в следующем пункте этого раздела.
    </app:alert>

    <br/>
    <h3>3.12.4.2.2 Пример с использованием хука</h3>
    <br/>

    <p>
        А теперь посмотрим, как написать этот компонент, используя функционал хуков.
    </p>

    <p>
        Возможно, вы подумали, что для очистки нам понадобится отдельный эффект. Но коды для
        добавления и удаления подписки связаны настолько тесно, что хук <code>useEffect</code> специально разработан
        с учетом того, чтобы поместить их вместе. Если ваш эффект возвращает функцию, React выполнит её,
        когда придет время для очистки:
    </p>

    <ce:code-example-6/>

    <p>
        <b>Почему мы вернули функцию из нашего эффекта?</b> Это опциональный механизм очистки для эффектов.
        Каждый эффект может возвращать функцию, которая после него выполнит очистку. Это позволяет
        нам поддерживать коды добавления и удаления подписок максимально близко друг к другу.
        Они являются частью одного эффекта!
    </p>

    <ad:ad-content-banner-3/>

    <p>
        <b>Когда именно React выполняет очистку в эффекте?</b> React производит очистку,
        когда компонент демонтируется. Однако, как мы уже знаем, эффекты запускаются
        для каждой отрисовки, а не единожды. Вот почему React также очищает эффекты
        предыдущей отрисовки, прежде чем запускать эффекты снова. Далее мы обсудим, почему
        это помогает избежать ошибок и как отказаться от такого поведения в том случае,
        если это создает проблемы с производительностью.
    </p>

    <app:alert title="Внимание!" type="warning">
        Вы не обязаны возвращать именованную функцию из эффекта. Функцию выше мы назвали
        <code>cleanup</code> только для того, чтобы прояснить её предназначение. Вы также можете вернуть
        стрелочную функцию либо вызвать какой-то другой код.
    </app:alert>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>3.12.4.3 Резюме</h2>
    <br/>

    <p>
        Мы узнали, что <code>useEffect</code> позволяет определять различные виды побочных
        эффектов, происходящих после отрисовки компонента. Некоторые эффекты
        могут требовать очистку, поэтому они должны возвращать функцию:
    </p>

    <ce:code-example-7/>

    <p>Эффекты, не имеющие фазы очистки, ничего не возвращают.</p>

    <ce:code-example-8/>

    <p>Хук эффекта объединяет оба случая под одним API.</p>

    <c:url var="rulesUrl" value="https://reactjs.org/docs/hooks-rules.html"/>

    <p>Если вы чувствуете, что у вас появилось неплохое понимание того, как работает хук эффекта,
        вы можете перейти к следующему разделу о <b><a href="${rulesUrl}">правилах использования хуков</a></b> прямо сейчас.</p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>3.12.4.4 Подсказки по использованию эффектов</h2>
    <br/>

    <p>
        Продолжим раздел, глубже рассматривая некоторые аспекты <code>useEffect</code>, которые, вероятно,
        будут интересны опытным пользователям React. Вам не обязательно копаться в них сейчас.
        Вы всегда можете вернуться к этому разделу, чтобы узнать больше о хуке эффекта.
    </p>

    <br/>
    <h3>3.12.4.4.1 Совет: используйте несколько эффектов для разделения задач</h3>
    <br/>

    <c:url var="motivationUrl" value="/core/hooks/introduction#motivation"/>
    <p>
        Одна из проблем, которую мы описали в <b><a href="${motivationUrl}">пункте о мотивации</a></b>, заключается
        в том, что методы ЖЦ класса часто содержат несвязанную логику, а связанная
        логика, наоборот, разбита по разным методам ЖЦ. Вот компонент, который совмещает
        счетчик и логику индикатора состояния друга из предыдущих примеров:
    </p>

    <ce:code-example-9/>

    <p>
        Обратите внимание, как логика, которая устанавливает <code>document.title</code>,
        продублирована в <code>componentDidMount</code> и <code>componentDidUpdate</code>. Логика подписки/отписки
        разбита между <code>componentDidMount</code> и <code>componentWillUnmount</code>. А <code>componentDidMount</code>
        содержит код для обеих задач.
    </p>

    <p>
        Как же хуки помогают решить эту проблему? По аналогии с многократным
        использованием хука состояния, можно использовать несколько эффектов. Это позволяет нам
        разбить несвязанную логику на разные эффекты:
    </p>

    <ce:code-example-10/>

    <p>
        <b>Хуки позволяют разделить код на основе того, что он делает</b>, а не на основании
        имён методов ЖЦ. React будет применять каждый эффект, используемый компонентом,
        в указанном порядке.
    </p>

    <br/>
    <h3>3.12.4.4.2 Объяснение: почему эффекты выполняются для каждого обновления?</h3>
    <br/>

    <p>
        Если вы привыкли к классам, вам может быть интересно, почему фаза очистки
        эффекта происходит после каждой повторной отрисовки, а не однократно при демонтировании.
        Давайте рассмотрим практический пример, чтобы понять, почему именно такой дизайн помогает
        создавать компоненты с меньшим количеством ошибок.
    </p>

    <p>
        Ранее в разделе мы представили пример компонента <code>FriendStatus</code>, который показывает,
        находится друг в сети или нет. Наш класс считывает <code>friend.id</code> из <code>this.props</code>, подписывается
        на статус друга после монтирования компонента и отменяет подписку при демонтировании:
    </p>

    <ce:code-example-11/>

    <p>
        Но что произойдет, если свойство <code>friend</code> изменится, пока компонент отображается
        на экране? Наш компонент будет продолжать отображать онлайн-статус, но... другого друга.
        Это ошибка. Также мы могли бы вызвать утечку памяти или крэш при демонтировании, так как
        вызов отмены подписки будет использовать неверный ID друга.
    </p>

    <ad:ad-content-banner-4/>

    <p>В компоненте-классе для обработки такого случая нам нужно
        добавить <code>componentDidUpdate</code>:</p>

    <ce:code-example-12/>

    <p>Отсутствие правильной обработки в <code>componentDidUpdate</code> является
        распространенным источником ошибок в приложениях React.</p>

    <p>Теперь рассмотрим версию этого компонента, которая использует хуки:</p>

    <ce:code-example-13/>

    <p>Она не страдает от такой ошибки. (Помимо прочего, мы не внесли никаких изменений.)</p>

    <p>
        Не существует специального кода для обработки обновлений, потому что <code>useEffect</code>
        обрабатывает их по умолчанию. Он очищает предыдущие эффекты перед применением
        следующих эффектов. Для наглядной иллюстрации вот вам последовательность вызовов
        подписки и отмены подписки, которые этот компонент может производить с течением времени:
    </p>

    <ce:code-example-14/>

    <p>Такое поведение обеспечивает согласованность по умолчанию и предотвращает
        ошибки, которые часто встречаются в компонентах-классах из-за отсутствия логики обновления.</p>

    <br/>
    <h3>3.12.4.4.3 Подсказка: как повысить производительность, указывая React пропустить срабатывание эффекта</h3>
    <br/>

    <p>
        В некоторых случаях очистка или применение эффекта после каждой отрисовки может
        привести к проблемам с производительностью. В компонентах-классах мы можем решить эту проблему,
        написав дополнительное сравнение с <code>prevProps</code> или <code>prevState</code> внутри <code>componentDidUpdate</code>:
    </p>

    <ce:code-example-15/>

    <p>
        Это довольно частое требование, поэтому оно встроено в API хука <code>useEffect</code>.
        Вы можете указать React пропустить выполнение эффекта, если определенные значения не
        изменились между повторными отрисовками. Для этого передайте массив в качестве
        необязательного второго аргумента в <code>useEffect</code>:
    </p>

    <ce:code-example-16/>

    <p>
        В примере выше мы передаем <code>[count]</code> в качестве второго аргумента. Что это значит?
        Если count равен <code>5</code>, а затем наш компонент повторно отрисовывается с <code>count</code>, все еще
        равным <code>5</code>, React будет сравнивать <code>[5]</code> из предыдущей отрисовки и <code>[5]</code> из следующей.
        Поскольку все элементы в массиве одинаковы <code>(5 === 5)</code>, React не вызовет эффект.
        Это и есть наша оптимизация.
    </p>

    <p>Когда мы отрисовываем компонент с <code>count</code>, обновленным до <code>6</code>, React будет
        сравнивать элементы в массиве <code>[5]</code> из предыдущей отрисовки с элементами в
        массиве <code>[6]</code> из следующей. На этот раз React повторно выполнит эффект, потому
        что <code>5 !== 6</code>. Если в массиве несколько элементов, React повторно запустит
        эффект, если отличается хотябы один из них.</p>

    <p>Это также справедливо для эффектов, которые имеют фазу очистки:</p>

    <ce:code-example-17/>

    <p>
        В будущем второй аргумент может быть добавлен автоматически при преобразовании во время сборки.
    </p>

    <c:url var="apiReferenceUrl" value="https://reactjs.org/docs/hooks-reference.html"/>
    <app:alert title="Внимание!" type="warning">
        Если вы используете эту оптимизацию, убедитесь, что массив содержит все значения из
        окружающей области видимости, которые изменяются со временем и используются эффектом.
        В противном случае ваш код будет ссылаться на устаревшие значения из предыдущих отрисовок.
        Также мы обсудим и другие варианты оптимизации в <b><a href="${apiReferenceUrl}">справке по API хуков</a></b>.
        <br/>
        <br/>
        Если вы хотите запустить эффект и очистить его только один раз (при монтировании и
        демонтировании), вы можете передать пустой массив <code>[]</code> в качестве второго аргумента. Это укажет
        React, что ваш эффект не зависит от каких-либо значений из <code>props</code> или <code>state</code>, поэтому его не нужно
        повторно выполнять. Это не обрабатывается как особый случай, а следует непосредственно из того,
        как работает массив входных значений. Несмотря на то, что передача <code>[]</code> ближе к знакомой ментальной
        модели <code>componentDidMount</code> и <code>componentWillUnmount</code>, мы рекомендуем не привыкать к такой форме записи, поскольку
        это часто приводит к ошибкам, что обсуждалось выше. Не забывайте, что React откладывает запуск
        <code>useEffect</code> до тех пор, пока браузер не выполнит прорисовку, поэтому выполнение дополнительной
        работы - это не проблема.
    </app:alert>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>3.12.4.5 Следующие шаги</h2>
    <br/>

    <c:url var="extraHooksUrl" value="https://reactjs.org/docs/hooks-reference.html"/>
    <p>
        Поздравляем! Это был довольно большой раздел, и мы надеемся, что к его концу
        нам удалось ответить на большинство ваших вопросов об эффектах. Вы изучили хук
        состояния и хук эффекта. Вместе они позволяют решить широкий спектр задач, охватывая
        большую часть случаев, где ранее использовались классы. В оставшихся случаях, могут
        оказаться полезными <b><a href="${extraHooksUrl}">дополнительные хуки</a></b>.
    </p>

    <p>
        Также становится понятно, как хуки решают проблемы, описанные в пункте о мотивации.
        Мы видели, как очистка эффекта предотвращает дублирование кода в <code>componentDidUpdate</code> и <code>componentWillUnmount</code>,
        распологает связанный код вместе и помогает избежать ошибок. Мы также видели, как можно
        разделить эффекты по назначению, что вообще невозможно для классов.
    </p>

    <p>В этот момент вы всё же можете задаться вопросом, как работают хуки.
        Как React знает, какой вызов <code>useState</code> какой переменной состояния соответствует
        между повторными отрисовками? Как React «сопоставляет» предыдущие и последующие
        эффекты при каждом обновлении? В следующем разделе мы узнаем о
        <b><a href="${rulesUrl}">правилах использования хуков</a></b> - эти правила необходимы для их работы.</p>

    <%-- <c:url var="Url" value=""/> --%>
    
    <%--
    <ul>
        <li>
            <p>

            </p>
        </li>
    </ul>
    --%>
    <%-- <app:alert title="Подсказка!" type="success"></app:alert> --%>
    <%-- <app:alert title="Внимание!" type="warning"></app:alert> --%>
    <%-- <code></code> --%>
    <%-- <b></b> --%>
    <%-- <code>&lt; &gt;</code> --%>
    <%-- <b><a href="${}"></a></b> --%>
    <%-- <b><a href="#"></a></b> --%>
    <%-- <a href="#"></a> --%>

</div>

<c:url var="prevPageUrl" value="/core/hooks/state-hook"/>
<c:url var="nextPageUrl" value="/core/hooks/rules"/>

<app:page-navigate
    pageStartAncor="pageStart"
    prevPageUrl="${prevPageUrl}"
    nextPageUrl="${nextPageUrl}"
/>