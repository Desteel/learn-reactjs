<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/core/render-prop" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>

<c:url var="reactRouterLibUrl" value="https://reacttraining.com/react-router/web/api/Route"/>
<c:url var="downshiftLibUrl" value="https://github.com/paypal/downshift"/>
<c:url var="useRenderPropUrl" value="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce?gi=47d07a97e8a"/>
<c:url var="reactMotionApiUrl" value="https://github.com/chenglou/react-motion"/>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page hello-world-example-page">
  <h1>3.12 Паттерн: свойство render</h1>

  <wg:p>
    Термин <b>«свойство render»</b> (в оригинале <b>«render prop»</b>) относится к простой методике совместного использования кода
    между компонентами React, принимающими свойство <code>prop</code>, значение которого является функцией.
  </wg:p>

  <wg:p>
    Компонент со свойством <code>render</code> принимает функцию, которая возвращает элемент React,
    и вызывает её вместо реализации своей собственной логики отрисовки.
  </wg:p>

  <ce:code-example-1/>

  <wg:p>
    Библиотеками, использующими такой подход, являются <wg:link href="${reactRouterLibUrl}">React Router</wg:link>
    и <wg:link href="${downshiftLibUrl}">Downshift</wg:link>.
  </wg:p>

  <wg:p>
    В этом разделе мы обсудим, почему полезно использовать свойство для отрисовки.
  </wg:p>

  <br/>
  <h2>3.12.1 Используйте «свойство render» для сквозной функциональности</h2>

  <wg:p>
    Компоненты являются основным элементом повторного использования кода в React,
    но не всегда очевидно, как совместно использовать состояние или поведение, которые
    один компонент инкапсулирует в другие компоненты, нуждающиеся в этом состоянии.
  </wg:p>

  <wg:p>
    Например, следующий компонент отслеживает позицию мыши в веб-приложении:
  </wg:p>

  <ce:code-example-2/>

  <wg:p>
    Когда курсор перемещается по экрану, компонент отображает его координаты (x, y) в <code>&lt;p&gt;</code>.
  </wg:p>

  <wg:p>
    Теперь возникает вопрос: как мы можем повторно использовать это поведение в другом компоненте?
    Другими словами, если другой компонент должен знать о позиции курсора, можем ли мы инкапсулировать
    это поведение таким образом, чтобы можно было легко поделиться им с этим компонентом?
  </wg:p>

  <wg:p>
    Поскольку компоненты являются базовой единицей повторного использования кода в React,
    попробуем немного отрефакторить код, чтобы использовать компонент <code>&lt;Mouse&gt;</code>, инкапсулирующий
    поведение, которое нам можно повторно использовать в любом другом месте.
  </wg:p>

  <ce:code-example-3/>

  <wg:p>
    Теперь компонент <code>&lt;Mouse&gt;</code> инкапсулирует все поведение, связанное с прослушиванием
    событий <code>mousemove</code> и хранением позиции <code>(x, y)</code> курсора, но он еще не может
    быть использован повторно.
  </wg:p>

  <wg:p>
    Предположим, что у нас есть компонент <code>&lt;Cat&gt;</code>, который отрисовывает изображение кота,
    преследующего мышь по экрану. Мы могли бы использовать свойство <code>&lt;Cat&gt; mouse = {{x, y}}&gt;</code>,
    сообщая компоненту координаты мыши, чтобы он знал, где разместить изображение на экране.
  </wg:p>

  <wg:p>
    В качестве первого приближения вы можете попробовать выполнить отрисовку компонента <code>&lt;Cat&gt;</code>
    внутри метода <code>render</code> компонента <code>&lt;Mouse&gt;</code>, например:
  </wg:p>

  <ce:code-example-4/>

  <wg:p>
    Такой подход будет работать для нашего конкретного случая, но мы не достигли
    цели по-настоящему инкапсулировать поведение для повторного использования. Теперь, каждый раз,
    когда нам нужна позиция мыши для какого-нибудь другого случая, мы должны создать новый компонент (т. е. по
    существу другой <code>&lt;MouseWithCat&gt;</code>), который отрисовывает что-то конкретное для данного случая.
  </wg:p>

  <wg:p>
    Вот где в силу вступает паттерн «свойство render»: вместо жесткого кодирования <code>&lt;Cat&gt;</code>
    внутри компонента <code>&lt;Mouse&gt;</code> и изменения результата его отрисовки, мы можем предоставить
    компоненту <code>&lt;Mouse&gt;</code> особое <b>свойство-функцию</b>, которое он использует для динамического определения того,
    что необходимо отрисовать. Это особое свойство и есть «свойство render».
  </wg:p>

  <ce:code-example-5/>

  <wg:p>
    Теперь, вместо клонирования компонента <code>&lt;Mouse&gt;</code> и жесткого кодирования чего-то еще в его <code>render</code>
    методе для конкретного варианта использования, мы предоставляем свойство <code>render</code>, которое <code>&lt;Mouse&gt;</code>
    может использовать для динамического определения того, что он отрисовывает.
  </wg:p>

  <wg:p>
    Более конкретно: <b>свойство</b> <code>render</code> <b>является свойством-функцией, которую компонент использует,
    для определения того, что ему необходимо отрисовывать.</b>
  </wg:p>

  <wg:p>
    Данный подход делает поведение, которое нам необходимо для совместного использования, чрезвычайно
    портативным. Чтобы получить это поведение, отрисуйте компонент <code>&lt;Mouse&gt;</code> с помощью свойства <code>render</code>,
    которое сообщает ему, что необходимо отрисовать, используя текущее положение <code>(x, y)</code> курсора.
  </wg:p>

  <wg:p>
    <b>Необходимо отметить одну важную деталь о свойстве</b> <code>render</code>: вы можете реализовать большинство
    компонентов более высокого порядка (HOC), используя обычный компонент со свойством <code>render</code>. Например,
    если вы предпочли бы иметь такой HOC как withMouse вместо <code>&lt;Mouse&gt;</code>, вы могли бы легко создать
    его с помощью обычного компонента <code>&lt;Mouse&gt;</code> со свойством <code>render</code>:
  </wg:p>

  <ce:code-example-6/>

  <wg:p>Таким образом, использование свойства <code>render</code> дает возможность применить любой паттерн.</wg:p>

  <br/>
  <h2>3.12.2 Использование свойств, отличных от "render"</h2>

  <wg:p>
    Важно помнить, что только потому, что паттерн называется «свойство render», вам не
    обязательно использовать свойство с именем <code>render</code> для реализации этого паттерна. Фактически,
    <wg:link href="${useRenderPropUrl}">любое свойство, которое является функцией и которое компонент использует, чтобы определить, что
    ему необходимо отрисовать</wg:link>, технически является паттерном «свойство render».
  </wg:p>

  <wg:p>
    Хотя приведенные выше примеры используют свойство <code>render</code>, мы могли бы
    так же легко использовать свойство <code>children</code>!
  </wg:p>

  <ce:code-example-7/>

  <wg:p>
    И помните, что на самом деле нет необходимости указывать свойство <code>children</code> в
    списке «атрибутов» вашего JSX элемента. Вместо этого вы можете поместить его прямо <b>внутри</b> этого элемента!
  </wg:p>

  <ce:code-example-8/>

  <wg:p>
    Вы можете увидеть этот подход в <wg:link href="${reactMotionApiUrl}">react-motion</wg:link> API.
  </wg:p>

  <wg:p>
    Поскольку этот метод немного необычен, вы при разработке API, вероятно, захотите явно указать, что свойство
    <code>children</code> должно быть функцией в ваших <code>propTypes</code>, как здесь:
  </wg:p>

  <ce:code-example-9/>

  <br/>
  <h2>3.12.3 Будьте внимательны, когда используете паттерн «свойство render» с React.PureComponent</h2>

  <wg:p>
    Использование свойства <code>render</code> может свести на нет все преимущество, которое дает
    использование <code>React.PureComponent</code>, если вы создаете функцию внутри метода <code>render</code>.
    Это происходит из-за того, что неглубокое сравнение свойств <code>props</code> всегда возвращает <code>false</code>
    для новых свойств <code>props</code>, и каждая отрисовка в этом случае генерирует новое значение для свойства <code>render</code>.
  </wg:p>

  <wg:p>
    Продолжим работу с нашим компонентом <code>&lt;Mouse&gt;</code>. Пусть <code>Mouse</code> будет наследоваться
    от <code>React.PureComponent</code>, а не от <code>React.Component</code>, тогда наш пример будет выглядеть так:
  </wg:p>

  <ce:code-example-10/>

  <wg:p>
    В этом примере каждый раз, когда <code>&lt;MouseTracker&gt;</code> отрисовывается, он генерирует новую функцию
    как значение свойства <code>&lt;Mouse render&gt;</code>, тем самым сводя на нет эффект
    наследования <code>&lt;Mouse&gt;</code> от <code>React.PureComponent</code>!
  </wg:p>

  <wg:p>
    Чтобы обойти эту проблему, иногда вы можете определить свойство как метод экземпляра, например:
  </wg:p>

  <ce:code-example-11/>

  <wg:p>
    В случаях, когда вы не можете заранее привязать метод экземпляра в конструкторе,
    компонент <code>&lt;Mouse&gt;</code> должен наследоваться от <code>React.PureComponent</code>.
  </wg:p>
</lt:layout>

<c:url var="prevPageUrl" value="portals"/>
<c:url var="nextPageUrl" value="error-boundaries"/>
<app:page-navigate prevPageUrl="${prevPageUrl}"
                   pageStartAncor="pageStart"
                   nextPageUrl="${nextPageUrl}"/>