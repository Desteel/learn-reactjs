<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>
<%@taglib prefix="rf" tagdir="/WEB-INF/tags/application/reference" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/reference/react-dom" %>

<c:url var="findDomNodeUrl" value="/core/strict-mode#legacy-find-dom-node"/>
<c:url var="portalsUrl" value="/core/portals"/>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page react-dom-page">
	<h1>4.3 ReactDOM</h1>
	
	<br/>

	<p class="introduction">Если вы загружаете React c помощью тега <code>&lt;script&gt;</code>, эти API верхнего уровня
		доступны в глобальном <code>ReactDOM</code>. Если вы используете ES6 с <b>npm</b>, вы можете
		написать <code>import ReactDOM from 'react-dom'</code>. Если вы используете ES5 с <b>npm</b>, вы
		можете написать <code>var ReactDOM = require ('react -dom')</code>.</p>

	<br/>
	<br/>
	<div class="gray-line"></div>
	<h2>4.3.1 Обзор</h2>
	<br/>

	<wg:p>Пакет react-dom предоставляет методы, специфичные для DOM,
		которые можно использовать на верхнем уровне вашего приложения и в качестве
		аварийного люка, чтобы выйти за пределы модели React, если это необходимо.
		Большинству ваших компонентов не нужно использовать этот модуль.</wg:p>

	<wg:p>
		<ul>
			<li><p><b><a href="#render">render()</a></b></p></li>
			<li><p><b><a href="#unmount-component-at-node">unmountComponentAtNode()</a></b></p></li>
			<li><p><b><a href="#find-dom-node">findDOMNode()</a></b></p></li>
		</ul>
	</wg:p>

	<wg:p>Начиная с <b>16</b> версии:</wg:p>

	<wg:p>
		<ul>
			<li><p><b><a href="#hydrate">hydrate()</a></b></p></li>
			<li><p><b><a href="#create-portal">createPortal()</a></b></p></li>
		</ul>
	</wg:p>

	<br/>
	<br/>
	<div class="gray-line"></div>
	<h2>4.3.2 Поддержка браузерами</h2>
	<br/>

	<wg:p>React поддерживает все популярные браузеры, включая Internet Explorer 9 и выше.</wg:p>

	<app:alert title="Замечание." type="warning">
		Не поддерживаются старые браузеры, которые не поддерживают методы ES5, но ваши
		приложения могут работать в старых браузерах, если на страницу включены полифилы,
		такие как <b>es5-shim</b> и <b>es5-sham</b>. Вы сами по себе, если решите пойти по этому пути.
	</app:alert>

	<br/>
	<br/>
	<div class="gray-line"></div>
	<h2>4.3.3 Справка</h2>
	<br/>
	
	<a name="render"></a>
	<rf:definition title="render()">
		<ce:code-example-1/>

		<wg:p>Отрисовывает элемент React в DOM в предоставленном <code>container</code> и вернёт ссылку
			на компонент (или возвращает значение <code>null</code> для компонентов без состояния).</wg:p>

		<wg:p>Если элемент React ранее был отрисован в <code>container</code>, то на нем выполнится
			обновление и DOM изменится только при необходимости, чтобы отобразить
			актуальный элемент React.</wg:p>

		<wg:p>Если предоставляется дополнительный коллбэк, он будет выполнен
			после отрисовки или обновления компонента.</wg:p>
		
		<app:alert title="Замечание." type="warning">
			<wg:p><code>ReactDOM.render()</code> управляет содержимым узла контейнера, который вы
				передали. Любые существующие элементы DOM внутри заменяются при первом
				вызове. В последующих вызовах используется эффективный React алгоритм
				сравнения DOM для эффективного обновления.</wg:p>
			
			<br/>
			
			<wg:p><code>ReactDOM.render()</code> не изменяет узел контейнера (только модифицирует
				дочерние элементы контейнера). Возможно вставить компонент в существующий
				узел DOM без перезаписи существующих дочерних элементов.</wg:p>
			
			<br/>
			
			<wg:p><code>ReactDOM.render()</code> в настоящий момент возвращает ссылку на корневой
				экземпляр <code>ReactComponent</code>. Однако использование этого возвращаемого значения
				является устаревшим и его следует избегать, поскольку будущие версии React
				в некоторых случаях могут отрисовывать компоненты асинхронно. Если вам
				нужна ссылка на экземпляр корневого <code>ReactComponent</code>, предпочтительным
				решением является привязка коллбэка <code>ref</code> к корневому элементу.</wg:p>
			
			<br/>
			
			<wg:p>Начиная с <b>16</b> версии использование <code>ReactDOM.render()</code> для гидратации контейнера,
				отрисованного сервером, устарело и будет удалено в React <b>17</b>.
				Вместо этого используйте <code>hydrate()</code>.</wg:p>
		</app:alert>
	</rf:definition>
	
	<a name="hydrate"></a>
	<rf:definition title="hydrate()">
		<ce:code-example-1.1/>

		<wg:p>Добавлен в версии <b>16</b>.</wg:p>

		<wg:p>То же, что и <code>render()</code>, но используется для гидратации контейнера, HTML
			содержимое которого было отрисовано компонентом <code>ReactDOMServer</code>. React
			попытается подключить слушатели событий к существующей разметке.</wg:p>

		<wg:p>React ожидает, что отрисовываемый контент будет идентичным между сервером
			и клиентом. Он может исправлять различия в текстовом контенте (например,
			временные метки), но вы должны рассматривать несоответствия как ошибки и
			исправлять их. В режиме <b>development</b> React предупреждает о несоответствиях
			во время гидратации. Нет никаких гарантий того, что различия атрибутов будут
			исправлены в случае несоответствий. Это важно по соображениям производительности,
			потому что в большинстве приложений несоответствия встречаются редко, и поэтому
			проверка всей разметки будет чрезмерно дорогостоящей.</wg:p>
		
		<p>
			Если атрибут отдельного элемента или его текстовое содержимое
			отличается между сервером и клиентом (например, отметка времени),
			вы можете отключить предупреждение, добавив <code>suppressHydrationWarning={true}</code> к
			элементу. Это работает только на один уровень глубины. Не злоупотребляйте данной функцией.
			Если это не текстовый контент, React по-прежнему не будет пытаться его исправить,
			поэтому такой код может оказаться несовместимым до будущих обновлений.
		</p>

		<wg:p>Если вам необходимо отрисовать что-то, что отличается на сервере и клиенте,
			вы можете сделать <b>двухфазную(двухпроходную)</b> отрисовку. Компоненты, которые
			отрисовывают что-то отличающееся на клиенте, могут считывать переменную состояния,
			такую как <code>this.state.isClient</code>, которую вы можете установить в <code>true</code> в методе
			<code>componentDidMount()</code>. Таким образом, отрисовка на первой фазе будет отображать
			тот же контент, что и сервер, избегая несоответствий, но дополнительная
			отрисовка(на второй фазе) будет осуществляться синхронно сразу после гидратации.
			Обратите внимание, что этот подход сделает ваши компоненты более медленными, потому
			что они должны отрисовываться дважды, поэтому используйте его с осторожностью.</wg:p>

		<wg:p>Помните, что нужно быть внимательным к удобству работы пользователя в случае медленных
			соединений. Код JavaScript может загружаться значительно позже, чем исходный HTML-результат
			отрисовки, поэтому, если вы отрисовываете что-то отличающееся в клиенте на второй фазе,
			переход к этому результату отрисовки может раздражать. Однако, если он выполняется хорошо,
			может оказаться полезным отобразить «оболочку» приложения на сервере и показать только
			некоторые дополнительные виджеты на клиенте. Чтобы узнать, как это сделать, не вызывая
			проблем с несоответствием разметки, обратитесь к объяснению в предыдущем абзаце.</wg:p>
	</rf:definition>
	
	<a name="unmount-component-at-node"></a>
	<rf:definition title="unmountComponentAtNode()">
		<ce:code-example-2/>

		<wg:p>
			Удаляет монтированный компонент React из DOM и очищает его обработчики событий и
			состояние. Если компонент не был монтирован в контейнер, вызов этой функции ничего
			не делает. Возвращает <code>true</code>, если компонент был демонтирован и <code>false</code>, если не
			найдено компонента для демонтирования.
		</wg:p>
	</rf:definition>
	
	<a name="find-dom-node"></a>
	<rf:definition title="findDOMNode()">
		<app:alert title="Внимание!" type="warning">
			<code>findDOMNode</code> - это аварийный люк, используемый для доступа к основному
			узлу DOM. В большинстве случаев его использование не рекомендуется,
			поскольку он нарушает абстракцию компонента. <b><a href="${findDomNodeUrl}">Он был признан устаревшим в
			строгом режиме</a></b>.
		</app:alert>
		
		<ce:code-example-3/>

		<wg:p>Если компонент был монтирован в DOM, этот метод возвращает соответствующий нативный
			элемент DOM браузера. Этот метод полезен для считывания значений из DOM, таких как
			значения полей формы и выполнения измерений DOM. <b>В большинстве случаев вы можете
			прикреплять ссылку <code>ref</code> на узел DOM и избегать использования</b> <code>findDOMNode</code>.
		</wg:p>

		<wg:p> Когда <code>render</code> возвращает <code>null</code> или <code>false</code>, <code>findDOMNode</code>
			возвращает значение <code>null</code>.</wg:p>

		<wg:p>Начиная с версии <b>16</b>:</wg:p>

		<wg:p>
			<ul>
				<li>когда <code>render</code> отображает строку, <code>findDOMNode</code> возвращает текстовый узел DOM,
					содержащий это значение</li>
				<li>компонент может вернуть фрагмент с несколькими дочерними элементами. В этом случае
					<code>findDOMNode</code> вернет узел DOM, соответствующий первому непустому дочернему элементу.</li>
			</ul>
		</wg:p>
		
		<app:alert title="Замечание." type="warning">
			<wg:p><code>findDOMNode</code> работает только на монтированных компонентах (то есть на компонентах,
				помещенных в DOM). Если вы попытаетесь вызвать его для компонента, который еще не
				был монтирован (например, вызов метода <code>findDOMNode()</code> в <code>render()</code> для компонента,
				который еще предстоит создать), будет выброшено исключение.</wg:p>
			
			<br/>
			
			<wg:p><code>findDOMNode</code> не может использоваться на функциональных компонентах.</wg:p>
		</app:alert>
	</rf:definition>

	<a name="create-portal"></a>
	<rf:definition title="createPortal()">
		<ce:code-example-4/>

		<p>Создает портал. Порталы предоставляют способ отображения дочерних элементов в узел DOM,
			который существует вне иерархии DOM-компонента (см. главу
			"<a href="${portalsUrl}">Порталы</a>").</p>
	</rf:definition>
</lt:layout>

<c:url var="prevPageUrl" value="react-component"/>
<c:url var="nextPageUrl" value="react-dom-server"/>
<app:page-navigate prevPageUrl="${prevPageUrl}"
                   pageStartAncor="pageStart"
                   nextPageUrl="${nextPageUrl}"/>