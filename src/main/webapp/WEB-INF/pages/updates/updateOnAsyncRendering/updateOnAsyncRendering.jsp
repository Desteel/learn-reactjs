<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/updates/updateOnAsyncRendering" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>

<c:url var="versioningSchemeUrl" value="https://reactjs.org/blog/2016/02/19/new-versioning-scheme.html"/>
<c:url var="derivedStateNecessityUrl" value="derived-state-necessity"/>
<c:url var="newMethodSignaturesUrl" value="https://gist.github.com/gaearon/88634d27abbc4feeb40a698f760f3264"/>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page async-rendering-update-page">
    <h1>Информация по асинхронной отрисовке компонентов</h1>

    <wg:p><b>27 Марта, 2018. Brian Vaughn (Брайан Вон)</b></wg:p>
    
    <wg:p>
        Уже более года команда React работает над реализацией асинхронной отрисовки.
        Теперь мы хотели бы поделиться с вами некоторыми уроками, которые усвоили, работая над этими функциями,
        а также некоторыми рекомендациями, которые помогут подготовить ваши компоненты для асинхронной
        отрисовки, когда она будет активирована.
    </wg:p>
    
    <wg:p>
        Один из самых больших уроков, который мы усвоили, заключается в том, что некоторые из наших устаревших методов
        жизненного цикла компонента, склонны поощрять небезопасные практики кодирования. Это:
    </wg:p>
    
    <wg:p>
        <ul>
            <li><code>componentWillMount</code></li>
            <li><code>componentWillReceiveProps</code></li>
            <li><code>componentWillUpdate</code></li>
        </ul>
    </wg:p>
    
    <p>
        Эти методы жизненного цикла часто понимались неправильно и злоупотреблялись. Более того, мы
        ожидаем, что их потенциальное злоупотребление может принести еще больше проблем вместе с асинхронной
        отрисовкой. Из-за этого мы добавим префикс <b>«UNSAFE_»</b> к данным методам в предстоящей версии. (Здесь
        префикс <b>«UNSAFE_»</b> относится не к безопасности. Он сообщает, что код, использующий данные методы, будет с
        большей вероятностью иметь ошибки в будущих версиях React, особенно после активации асинхронной отрисовки.)
    </p>

    <br/>
    <h2>Путь постепенной миграции</h2>
    
    <p><a href="${versioningSchemeUrl}">React следует схеме управления версиями</a>, поэтому
        данное изменение будет постепенным. Наш текущий план:</p>

    <p>
        <ul>
            <li><b>Релиз 16.3</b>: Вводит псевдонимы/алиасы для небезопасных методов жизненного цикла,
                <code>UNSAFE_componentWillMount</code>, <code>UNSAFE_componentWillReceiveProps</code> и
                <code>UNSAFE_componentWillUpdate</code>. (В данном релизе будут работать и старые имена методов жизненного
                цикла, и новые псевдонимы.)
            </li>
            <li><b>Будущие релизы 16.x</b>: Будут включать предупреждение об устаревании
                методов <code>componentWillMount</code>, <code>componentWillReceiveProps</code> и <code>componentWillUpdate</code>.
                (В данных релизах будут работать и старые имена методов жизненного цикла, и
                новые псевдонимы, но старые имена будут выводить предупреждение в режиме разработки.)
            </li>
            <li><b>Релиз 17.0</b>: Удалит методы <code>componentWillMount</code>,
                <code>componentWillReceiveProps</code> и <code>componentWillUpdate</code>.
                (С того момента будут работать только новые <code>UNSAFE_</code> имена методов жизненного цикла).
            </li>
        </ul>
    </p>

    <p>
        <b>Обратите внимание: если вы являетесь разработчиком приложения React, вам не нужно ничего делать в
            отношении устаревших методов. Главная цель предстоящего релиза версии 16.3 заключается в том, чтобы
            позволить разработчикам проектов с открытым исходным кодом обновлять свои библиотеки до возникновения
            любых предупреждений об устаревании. Данные предупреждения не будут активированы вплоть до следующего
            выпуска 16.x.
        </b>
    </p>

    <p>
        Мы поддерживаем более 50 000 компонентов React в Facebook, и мы не планируем сразу их всех переписывать.
        Мы понимаем, что миграция требует времени. Мы будем проходить постепенный путь миграции
        вместе со всеми в сообществе React.
    </p>

    <br/>
    <h2>Миграция с устаревших методов жизненного цикла</h2>

    <p>
        Если вы хотите начать использовать новый API компонентов, представленный в React 16.3
        (или если вы являетесь разработчиком, который хочет обновить свою библиотеку заранее),
        вот несколько примеров, которые, как мы надеемся, помогут вам посмотреть на компоненты
        под другим углом. Со временем мы планируем добавить дополнительные «рецепты» к нашей
        документации, которые покажут, как можно выполнять общие задачи таким образом, чтобы можно было избежать
        использования проблемных методов жизненного цикла.
    </p>

    <p>Прежде чем мы начнем, кратко рассмотрим изменения жизненного цикла, запланированные для версии 16.3:</p>

    <p>
        <ul>
            <li>Мы <b>добавляем следующие псевдонимы методов жизненного цикла</b>: <code>UNSAFE_componentWillMount</code>,
                <code>UNSAFE_componentWillReceiveProps</code> и <code>UNSAFE_componentWillUpdate</code>. (Будут поддерживаться
                        как старые имена методов жизненного цикла, таки и новые псевдонимы.)
            </li>
            <li>Мы <b>представляем два новых метода жизненного цикла</b>:
                статические <code>getDerivedStateFromProps</code> и <code>getSnapshotBeforeUpdate</code>.
            </li>
        </ul>
    </p>

    <br/>
    <h3>Новый метод жизненного цикла: getDerivedStateFromProps</h3>
    <br/>

    <ce:code-example-1 />

    <p>
        Новый статический метод жизненного цикла <code>getDerivedStateFromProps</code> запускается
        после создания экземпляра компонента, перед его повторной отрисовкой. Он может
        вернуть объект для обновления состояния <code>state</code> или <code>null</code>, чтобы указать, что новые
        свойства <code>props</code> не требуют каких-либо обновлений состояния <code>state</code>.
    </p>

    <p>
        Вместе с <code>componentDidUpdate</code> данный новый метод жизненного цикла должен охватывать
        все случаи использования устаревшего <code>componentWillReceiveProps</code>.
    </p>

    <app:alert type="warning" title="Внимание!">
        Как устаревший <code>componentWillReceiveProps</code>, так и новый <code>getDerivedStateFromProps</code>
        методы придают значительную сложность компонентам. Это часто приводит к ошибкам.
        Рассмотрим <a href="${derivedStateNecessityUrl}"><b>более простые альтернативы
        производному состоянию</b></a>, чтобы сделать компоненты предсказуемыми и поддерживаемыми.
    </app:alert>

    <br/>
    <h3>Новый метод жизненного цикла: getSnapshotBeforeUpdate</h3>
    <br/>

    <p>
        Новый метод жизненного цикла <code>getSnapshotBeforeUpdate</code> вызывается непосредственно перед
        произведением мутаций (например, перед обновлением DOM). Возвращаемое значение для данного
        метода жизненного цикла будет передано в качестве третьего параметра в <code>componentDidUpdate</code>.
        (Данный метод жизненного цикла нужен не так часто, но может быть полезен в таких случаях,
        как ручное сохранение положения прокрутки во время перерисовок).
    </p>

    <p>
        Вместе с <code>componentDidUpdate</code> данный новый метод жизненного цикла должен охватывать
        все случаи использования устаревшего <code>componentWillUpdate</code>.
    </p>

    <p>
        <a href="${newMethodSignaturesUrl}"><b>Вы можете найти их сигнатуры здесь.</b></a>
    </p>

    <p>Далее мы рассмотрим примеры использования данных методов ЖЦ.</p>

    <br/>
    <h2>Примеры</h2>

    <p>
        <ul>
            <li><a href="#e1"><b>Инициализация состояния</b></a></li>
            <li><a href="#e2"><b>Получение внешних данных</b></a></li>
            <li><a href="#e3"><b>Добавление слушателей событий (или подписок)</b></a></li>
            <li><a href="#e4"><b>Обновление состояния state на основе свойств props</b></a></li>
            <li><a href="#e5"><b>Вызов внешних коллбэков</b></a></li>
            <li><a href="#e6"><b>Побочные эффекты при изменении свойств props</b></a></li>
            <li><a href="#e7"><b>Получение внешних данных при изменении свойств props</b></a></li>
            <li><a href="#e8"><b>Чтение свойств DOM перед обновлением</b></a></li>
        </ul>
    </p>

    <br/>
    <app:alert type="warning" title="Внимание!">
        Для краткости приведенные ниже примеры написаны с использованием трансформации
        экспериментальных свойств класса, но те же стратегии миграции применимы и без этого.
    </app:alert>

    <br/>
    <a name="e1"></a>
    <h3>Инициализация состояния</h3>

    <p></p>
    <p></p>
</lt:layout>

<c:url var="prevPageUrl" value="react-v16.4.0-pointer-events"/>
<app:page-navigate pageStartAncor="pageStart" prevPageUrl="${prevPageUrl}"/>