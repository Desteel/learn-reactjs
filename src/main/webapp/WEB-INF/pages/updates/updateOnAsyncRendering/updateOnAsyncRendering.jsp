<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/updates/updateOnAsyncRendering" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>

<c:url var="versioningSchemeUrl" value="https://reactjs.org/blog/2016/02/19/new-versioning-scheme.html"/>
<c:url var="derivedStateNecessityUrl" value="derived-state-necessity"/>
<c:url var="newMethodSignaturesUrl" value="https://gist.github.com/gaearon/88634d27abbc4feeb40a698f760f3264"/>
<c:url var="prefetchDataUrl" value="https://gist.github.com/bvaughn/89700e525ff423a75ffb63b1b1e30a8f"/>
<c:url var="jsConfIcelandUrl" value="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html"/>
<c:url var="createUbscriptionUrl" value="https://github.com/facebook/react/tree/master/packages/create-subscription"/>
<c:url var="exampleUrl" value="https://gist.github.com/bvaughn/d569177d70b50b58bff69c3c4a5353f3"/>
<c:url var="updatingExternalDataWhenPropsChangesUsingPromisesUrl" value="https://gist.github.com/bvaughn/982ab689a41097237f6e9860db7ca8d6"/>
<c:url var="axiosUrl" value="https://www.npmjs.com/package/axios"/>
<c:url var="reactLifecyclesCompatUrl" value="https://github.com/reactjs/react-lifecycles-compat"/>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page async-rendering-update-page">
    <h1>Информация по асинхронной отрисовке компонентов</h1>

    <wg:p><b>27 Марта, 2018. Brian Vaughn (Брайан Вон)</b></wg:p>
    
    <wg:p>
        Уже более года команда React работает над реализацией асинхронной отрисовки.
        Теперь мы хотели бы поделиться с вами некоторыми уроками, которые усвоили, работая над этими функциями,
        а также некоторыми рекомендациями, которые помогут подготовить ваши компоненты для асинхронной
        отрисовки, когда она будет активирована.
    </wg:p>
    
    <wg:p>
        Один из самых больших уроков, который мы усвоили, заключается в том, что некоторые из наших устаревших методов
        жизненного цикла компонента, склонны поощрять небезопасные практики кодирования. Это:
    </wg:p>
    
    <wg:p>
        <ul>
            <li><code>componentWillMount</code></li>
            <li><code>componentWillReceiveProps</code></li>
            <li><code>componentWillUpdate</code></li>
        </ul>
    </wg:p>
    
    <p>
        Эти методы жизненного цикла часто понимались неправильно и злоупотреблялись. Более того, мы
        ожидаем, что их потенциальное злоупотребление может принести еще больше проблем вместе с асинхронной
        отрисовкой. Из-за этого мы добавим префикс <b>«UNSAFE_»</b> к данным методам в предстоящей версии. (Здесь
        префикс <b>«UNSAFE_»</b> относится не к безопасности. Он сообщает, что код, использующий данные методы, будет с
        большей вероятностью иметь ошибки в будущих версиях React, особенно после активации асинхронной отрисовки.)
    </p>

    <br/>
    <h2>Путь постепенной миграции</h2>
    
    <p><a href="${versioningSchemeUrl}">React следует схеме управления версиями</a>, поэтому
        данное изменение будет постепенным. Наш текущий план:</p>

    <p>
        <ul>
            <li><b>Релиз 16.3</b>: Вводит псевдонимы/алиасы для небезопасных методов жизненного цикла,
                <code>UNSAFE_componentWillMount</code>, <code>UNSAFE_componentWillReceiveProps</code> и
                <code>UNSAFE_componentWillUpdate</code>. (В данном релизе будут работать и старые имена методов жизненного
                цикла, и новые псевдонимы.)
            </li>
            <li><b>Будущие релизы 16.x</b>: Будут включать предупреждение об устаревании
                методов <code>componentWillMount</code>, <code>componentWillReceiveProps</code> и <code>componentWillUpdate</code>.
                (В данных релизах будут работать и старые имена методов жизненного цикла, и
                новые псевдонимы, но старые имена будут выводить предупреждение в режиме разработки.)
            </li>
            <li><b>Релиз 17.0</b>: Удалит методы <code>componentWillMount</code>,
                <code>componentWillReceiveProps</code> и <code>componentWillUpdate</code>.
                (С того момента будут работать только новые <code>UNSAFE_</code> имена методов жизненного цикла).
            </li>
        </ul>
    </p>

    <p>
        <b>Обратите внимание: если вы являетесь разработчиком приложения React, вам не нужно ничего делать в
            отношении устаревших методов. Главная цель предстоящего релиза версии 16.3 заключается в том, чтобы
            позволить разработчикам проектов с открытым исходным кодом обновлять свои библиотеки до возникновения
            любых предупреждений об устаревании. Данные предупреждения не будут активированы вплоть до следующего
            выпуска 16.x.
        </b>
    </p>

    <p>
        Мы поддерживаем более 50 000 компонентов React в Facebook, и мы не планируем сразу их всех переписывать.
        Мы понимаем, что миграция требует времени. Мы будем проходить постепенный путь миграции
        вместе со всеми в сообществе React.
    </p>

    <br/>
    <h2>Миграция с устаревших методов жизненного цикла</h2>

    <p>
        Если вы хотите начать использовать новый API компонентов, представленный в React 16.3
        (или если вы являетесь разработчиком, который хочет обновить свою библиотеку заранее),
        вот несколько примеров, которые, как мы надеемся, помогут вам посмотреть на компоненты
        под другим углом. Со временем мы планируем добавить дополнительные «рецепты» к нашей
        документации, которые покажут, как можно выполнять общие задачи таким образом, чтобы можно было избежать
        использования проблемных методов жизненного цикла.
    </p>

    <p>Прежде чем мы начнем, кратко рассмотрим изменения жизненного цикла, запланированные для версии 16.3:</p>

    <p>
        <ul>
            <li>Мы <b>добавляем следующие псевдонимы методов жизненного цикла</b>: <code>UNSAFE_componentWillMount</code>,
                <code>UNSAFE_componentWillReceiveProps</code> и <code>UNSAFE_componentWillUpdate</code>. (Будут поддерживаться
                        как старые имена методов жизненного цикла, таки и новые псевдонимы.)
            </li>
            <li>Мы <b>представляем два новых метода жизненного цикла</b>:
                статические <code>getDerivedStateFromProps</code> и <code>getSnapshotBeforeUpdate</code>.
            </li>
        </ul>
    </p>

    <br/>
    <h3>Новый метод жизненного цикла: getDerivedStateFromProps</h3>
    <br/>

    <ce:code-example-1 />

    <p>
        Новый статический метод жизненного цикла <code>getDerivedStateFromProps</code> запускается
        после создания экземпляра компонента, перед его повторной отрисовкой. Он может
        вернуть объект для обновления состояния <code>state</code> или <code>null</code>, чтобы указать, что новые
        свойства <code>props</code> не требуют каких-либо обновлений состояния <code>state</code>.
    </p>

    <p>
        Вместе с <code>componentDidUpdate</code> данный новый метод жизненного цикла должен охватывать
        все случаи использования устаревшего <code>componentWillReceiveProps</code>.
    </p>

    <app:alert type="warning" title="Внимание!">
        Как устаревший <code>componentWillReceiveProps</code>, так и новый <code>getDerivedStateFromProps</code>
        методы придают значительную сложность компонентам. Это часто приводит к ошибкам.
        Рассмотрим <a href="${derivedStateNecessityUrl}"><b>более простые альтернативы
        производному состоянию</b></a>, чтобы сделать компоненты предсказуемыми и поддерживаемыми.
    </app:alert>

    <br/>
    <h3>Новый метод жизненного цикла: getSnapshotBeforeUpdate</h3>
    <br/>

    <p>
        Новый метод жизненного цикла <code>getSnapshotBeforeUpdate</code> вызывается непосредственно перед
        произведением мутаций (например, перед обновлением DOM). Возвращаемое значение для данного
        метода жизненного цикла будет передано в качестве третьего параметра в <code>componentDidUpdate</code>.
        (Данный метод жизненного цикла нужен не так часто, но может быть полезен в таких случаях,
        как ручное сохранение положения прокрутки во время перерисовок).
    </p>

    <p>
        Вместе с <code>componentDidUpdate</code> данный новый метод жизненного цикла должен охватывать
        все случаи использования устаревшего <code>componentWillUpdate</code>.
    </p>

    <p>
        <a href="${newMethodSignaturesUrl}"><b>Вы можете найти их сигнатуры здесь.</b></a>
    </p>

    <p>Далее мы рассмотрим примеры использования данных методов ЖЦ.</p>

    <br/>
    <h2>Примеры</h2>

    <p>
        <ul>
            <li><a href="#e1"><b>Инициализация состояния</b></a></li>
            <li><a href="#e2"><b>Получение внешних данных</b></a></li>
            <li><a href="#e3"><b>Добавление слушателей событий (или подписок)</b></a></li>
            <li><a href="#e4"><b>Обновление состояния state на основе свойств props</b></a></li>
            <li><a href="#e5"><b>Вызов внешних коллбэков</b></a></li>
            <li><a href="#e6"><b>Побочные эффекты при изменении свойств props</b></a></li>
            <li><a href="#e7"><b>Получение внешних данных при изменении свойств props</b></a></li>
            <li><a href="#e8"><b>Чтение DOM свойств перед обновлением</b></a></li>
        </ul>
    </p>

    <br/>
    <app:alert type="warning" title="Внимание!">
        Для краткости приведенные ниже примеры написаны с использованием трансформации
        экспериментальных свойств класса, но те же стратегии миграции применимы и без этого.
    </app:alert>

    <br/>
    <a name="e1"></a>
    <h3>Инициализация состояния</h3>

    <p>В данном примере показан компонент с вызовом <code>setState</code>
        внутри <code>componentWillMount</code>:</p>

    <ce:code-example-3/>

    <p>Простейшим рефакторингом для такого случая является перенос
        инициализации состояния в конструктор или инициализатор свойств, например:</p>

    <ce:code-example-4/>

    <br/>
    <a name="e2"></a>
    <h3>Получение внешних данных</h3>

    <p>Ниже приведен пример компонента, который использует
        <code>componentWillMount</code> для извлечения внешних данных:</p>

    <ce:code-example-5/>

    <p>Вышеприведенный код проблематичен как для серверной отрисовки (где внешние данные не
        будут использоваться), так и для предстоящего режима асинхронной отрисовки (где запрос
        может быть инициирован множество раз).</p>

    <p>Рекомендуемый путь апгрейда для большинства ситуаций - это перенос
        логики извлечения данных в <code>componentDidMount</code>:</p>

    <ce:code-example-6/>

    <p>Существует распространенное заблуждение, что логика извлечения данных в
        <code>componentWillMount</code> позволяет избежать отображения пустого состояния при первой отрисовке.
        На практике это никогда не соответствовало действительности, потому что React всегда выполнял
        отрисовку сразу после <code>componentWillMount</code>. Если данные не доступны к моменту
        срабатывания <code>componentWillMount</code>, первая отрисовка будет по-прежнему показывать
        состояние загрузки независимо от того, где вы инициируете извлечение данных. Вот
        почему перенос <code>fetch</code> в <code>componentDidMount</code> не дает ощутимой разницы в подавляющем
        большинстве случаев.</p>

    <br/>
    <app:alert type="warning" title="Внимание!">
        В некоторых продвинутых случаях использования (например, библиотеки, такие как Relay), возможно,
        захочется поэкспериментировать с предварительной асинхронной выборкой данных. Пример того,
        как это можно сделать, <b><a href="${prefetchDataUrl}">доступен здесь</a></b>.
        <br/><br/>
        В более долгосрочной перспективе канонический способ получения данных в компонентах React,
        скорее всего, будет основан на API-интерфейсе <b>«приостановка»</b>, представленном
        на <a href="${jsConfIcelandUrl}"><b>JSConf Iceland</b></a>. Как решения по простому извлечению
        данных, так и библиотеки, такие как Apollo или Relay,
        смогут использовать его у себя под капотом. Он наименее многословен, чем любое из
        вышеперечисленных решений, но, к сожалению, не будет завершен к моменту выпуска 16.3.
        <br/><br/>
        В настоящее время при поддержке отрисовки на сервере необходимо предоставлять данные
        синхронно - ранее для этой цели часто использовался <code>componentWillMount</code>, но в качестве
        замены можно использовать и конструктор. Предстоящий API-интерфейс приостановки сделает
        асинхронную выборку данных возможной (и в аккуратной форме) как для серверной, так и для клиентской отрисовок.
    </app:alert>

    <br/>
    <a name="e3"></a>
    <h3>Добавление слушателей событий (или подписок)</h3>

    <p>Ниже приведен пример компонента, который подписывается на диспетчер внешних событий при монтировании:</p>

    <ce:code-example-7/>

    <p>К сожалению, это может привести к утечкам памяти как для случая отрисовки на сервере
        (где <code>componentWillUnmount</code> никогда не будет вызван), так и для асинхронной отрисовки
        (где отрисовка может быть прервана до своего завершения, в результате чего
        <code>componentWillUnmount</code> не будет вызван).</p>

    <p>Люди часто предполагают, что <code>componentWillMount</code> и <code>componentWillUnmount</code> всегда сопряжены,
        но это не гарантируется. Только единожды, после того как был вызван <code>componentDidMount</code>,
        React гарантирует, что <code>componentWillUnmount</code> будет вызван позже для очистки.</p>

    <p>По этой причине рекомендуемым способом добавления слушателей/подписок является
        использование метода жизненного цикла <code>componentDidMount</code>:</p>

    <ce:code-example-8/>

    <p>Иногда важно обновлять подписки в ответ на изменения свойств. Если вы используете
        библиотеку, такую как <b>Redux</b> или <b>MobX</b>, компонент-контейнер библиотеки должен обрабатывать
        это за вас. Для разработчиков приложений мы создали небольшую библиотеку,
        <a href="${createUbscriptionUrl}"><b>create-subscription</b></a>,
        чтобы помочь с этим. Мы опубликуем ее вместе с React 16.3.</p>

    <ce:code-example-9/>

    <app:alert type="warning" title="Внимание!">
        Библиотекам, таким как <b>Relay/Apollo</b>, следует вручную управлять подписками с помощью
        тех же методов, что и <a href="${createUbscriptionUrl}"><b>create-subscription</b></a> использует у
        себя под капотом (как показано <a href="${exampleUrl}"><b>здесь</b></a>), а также таким образом, который наиболее оптимален
        для использования в данной библиотеке.
    </app:alert>

    <br/>
    <a name="e4"></a>
    <h3>Обновление состояния state на основе свойств props</h3>

    <app:alert type="warning" title="Внимание!">
        Как старый <code>componentWillReceiveProps</code>, так и новый <code>getDerivedStateFromProps</code>
        методы добавляют значительную долю сложности компонентам. Это часто приводит к ошибкам.
        <a href="${derivedStateNecessityUrl}"><b>Рассмотрите более простые альтернативы</b></a> производному
        состоянию, чтобы сделать компоненты предсказуемыми и поддерживаемыми.
    </app:alert>

    <p>Ниже приведен пример компонента, который использует устаревший метод ЖЦ
        <code>componentWillReceiveProps</code> для обновления состояния на основе новых
        значений свойств props:</p>

    <ce:code-example-10/>

    <p>Хотя вышеупомянутый код не содержит проблем, метод ЖЦ
        <code>componentWillReceiveProps</code> часто используется неправильно, что создает
        разные проблемы. По этой причине командой принято решение сделать его устаревшим.</p>

    <p>Начиная с версии 16.3, рекомендуемый способ обновления состояния в ответ на изменения
        свойств <code>props</code> связан с новым статическим методом ЖЦ <code>getDerivedStateFromProps</code>.
        (Данный метод вызывается, после того как компонент был создан и каждый раз,
        когда он получает новые свойства):</p>

    <ce:code-example-11/>

    <p>В приведенном выше примере вы можете заметить, что <code>props.currentRow</code> отражен в
        состоянии (как <code>state.lastRow</code>). Это позволяет <code>getDerivedStateFromProps</code> получить
        доступ к предыдущему значению свойства таким же образом, как это
        сделано в <code>componentWillReceiveProps</code>.</p>

    <p>Вы могли задаться вопросом, почему мы просто не передаем предыдущие свойства в
        качестве параметра <code>getDerivedStateFromProps</code>. Мы рассматривали такой вариант при
        разработке API, но в конечном итоге выступили против него по двум причинам:</p>

    <p>
        <ul>
            <li>Параметр <code>prevProps</code> был бы нулевым при первом вызове <code>getDerivedStateFromProps</code>
                (после создания экземпляра), что требует добавление проверки <code>if-not-null</code>
                 для доступа к <code>prevProps</code> в любой момент времени.</li>
            <li>Не передавать предыдущие свойства этой функции - это шаг к освобождению памяти в
                будущих версиях React. (Если React не нужно передавать предыдущие свойства методам ЖЦ,
                то тогда ему не нужно хранить предыдущий объект <code>props</code> в памяти.)</li>
        </ul>
    </p>

    <app:alert type="warning" title="Внимание!">
        Если вы пишете компонент для общего использования, полифил <code>react-lifecycles-compat</code>
        позволяет использовать новый метод ЖЦ <code>getDerivedStateFromProps</code> в старых версиях React.
        Подробнее о том, как его использовать будет показано ниже.
    </app:alert>

    <br/>
    <a name="e5"></a>
    <h3>Вызов внешних коллбэков</h3>

    <p>Ниже приведен пример компонента, который вызывает внешнюю функцию
        при изменении своего внутреннего состояния:</p>

    <ce:code-example-12/>

    <p>Иногда люди используют <code>componentWillUpdate</code> из-за неуместного опасения, что якобы
        к моменту срабатывания <code>componentDidUpdate</code>, будет «слишком поздно» обновлять состояние
        других компонентов. Но это не тот случай. React гарантирует, что любые вызовы <code>setState</code>,
        которые происходят внутри <code>componentDidMount</code> и <code>componentDidUpdate</code>, будут произведены
        до того, как пользователь увидит обновленный интерфейс. В общем, лучше избегать таких
        каскадных обновлений, как это, хотя в некоторых случаях они бывают необходимы (например, если
        вам нужно спозиционировать всплывающую подсказку после измерения отображённого DOM элемента).</p>

    <p>Тем не менее, небезопасно использовать <code>componentWillUpdate</code> для этой цели в
        асинхронном режиме, поскольку внешний коллбэк для одного обновления может быть вызван несколько раз.
        Вместо него должен использоваться метод ЖЦ <code>componentDidUpdate</code>, так
        как он гарантированно будет вызываться только один раз для одного обновления:</p>

    <ce:code-example-13/>

    <br/>
    <a name="e6"></a>
    <h3>Побочные эффекты при изменении свойств props</h3>

    <p>Как и в примере выше, иногда у компонентов есть побочные эффекты,
        когда свойства <code>props</code> изменяется.</p>

    <ce:code-example-14/>

    <p>Как и <code>componentWillUpdate</code>, метод <code>componentWillReceiveProps</code> может вызываться
        несколько раз для одного обновления. По этой причине важно избегать
        появления побочных эффектов в данном методе. Вместо него должен использоваться
        метод <code>componentDidUpdate</code>, поскольку он гарантированно будет вызываться
        только один раз за одно обновление:</p>

    <ce:code-example-15/>

    <br/>
    <a name="e7"></a>
    <h3>Получение внешних данных при изменении свойств props</h3>

    <p>Ниже приведен пример компонента, который извлекает внешние
        данные на основе значений из <code>props</code>:</p>

    <ce:code-example-16/>

    <p>Рекомендуемый путь апгрейда для этого компонента - перенос обновлений
        данных в <code>componentDidUpdate</code>. Вы также можете использовать новый метод
        ЖЦ <code>getDerivedStateFromProps</code> для очистки устаревших данных перед
        отрисовкой новых свойств:</p>

    <ce:code-example-17/>

    <br/>
    <app:alert type="warning" title="Внимание!">
        Если вы используете HTTP-библиотеку, которая поддерживает отмену,
        например, <a href="${axiosUrl}"><b>axios</b></a>, то при демонтировании очень просто отменить запрос,
        находящийся в состоянии выполнения. При использовании нативных Promise вы можете
        использовать подход, подобный <a href="${updatingExternalDataWhenPropsChangesUsingPromisesUrl}"><b>показанному здесь</b></a>.
    </app:alert>

    <br/>
    <a name="e8"></a>
    <h3>Чтение DOM свойств перед обновлением</h3>

    <p>Ниже приведен пример компонента, который считывает свойство из DOM перед
        обновлением, для поддержки положения прокрутки в списке:</p>

    <ce:code-example-18/>

    <p>В приведенном выше примере <code>componentWillUpdate</code> используется для чтения
        свойства DOM. Однако при асинхронной отрисовке могут возникать задержки
        между методами ЖЦ фазы отрисовки (render-фазы) (например, <code>componentWillUpdate</code> и <code>render</code>)
        и методами ЖЦ фазы фиксации (commit-фазы) (например, <code>componentDidUpdate</code>). Если в это
        время пользователь производит действия, наподобие изменения размера окна,
        значение <code>scrollHeight</code>, считанное в <code>componentWillUpdate</code>, будет устаревшим.</p>

    <p>Два метода ЖЦ могут использоваться вместе следующим образом:</p>

    <ce:code-example-19/>

    <app:alert type="warning" title="Внимание!">
        Если вы пишете компонент для общего использования, полифил <code>react-lifecycles-compat</code>
        позволяет использовать новый метод ЖЦ <code>getSnapshotBeforeUpdate</code> в старых версиях React.
        Подробнее о том, как его использовать будет показано ниже.
    </app:alert>

    <br/>
    <h2>Другие сценарии</h2>

    <p>Несмотря на то, что в этом статье мы пытались охватить наиболее распространенные
        случаи использования, мы признаем, что все же могли что-то пропустить.
        Если вы используете <code>componentWillMount</code>, <code>componentWillUpdate</code> или <code>componentWillReceiveProps</code>
        какими-либо способами, которые не охвачены этой статьей, и не уверены, как правильно мигрировать с
        этих методов ЖЦ, пожалуйста, создайте новую проблему рядом с нашей документацией,
        предоставив примеры кода и как можно попутной информации. Мы
        обновим данную статью новыми альтернативными паттернами по мере их появления.</p>

    <br/>
    <h2>Разработчики проектов с открытым исходным кодом</h2>

    <p>Разработчики проектов с открытым исходным кодом могут задаваться вопросом:
        что означают эти изменения для компонентов общего пользования? Если вы реализуете
        приведенные выше предложения, что произойдет с компонентами, которые зависят от
        нового статического метода ЖЦ <code>getDerivedStateFromProps</code>? Вам тоже придётся выпустить
        новую <b>major</b>-версию проекта и отказаться от совместимости с React <b>16.2</b> и старше?</p>

    <p>К счатью, нет!</p>

    <p>Когда будет опубликован React <b>16.3</b>, мы также опубликуем и новый пакет <b>npm</b>,
        <a href="${reactLifecyclesCompatUrl}"><b>react-lifecycles-compat</b></a>. Данный
        пакет будет производить полизаполнение компонентов таким образом, что
        новые методы ЖЦ <code>getDerivedStateFromProps</code> и <code>getSnapshotBeforeUpdate</code> также будут работать
        и с более старыми версиями React (<b>0.14.9+</b>).</p>

    <p>Чтобы использовать этот полифил, сначала добавьте его как зависимость в вашу библиотеку:</p>

    <ce:code-example-20/>

    <p>Затем обновите свои компоненты, чтобы использовать новые методы ЖЦ (как описано выше).</p>

    <p>Наконец, используйте полифил для того, чтобы ваш компонент был обратно совместим
        со старыми версиями React:</p>

    <ce:code-example-21/>
</lt:layout>

<c:url var="prevPageUrl" value="react-v16.2.0-fragments-improved-support"/>
<c:url var="nextPageUrl" value="react-v16.3.0"/>

<app:page-navigate pageStartAncor="pageStart"
                   prevPageUrl="${prevPageUrl}"
                   nextPageUrl="${nextPageUrl}"/>