<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/updates/updateOnAsyncRendering" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>

<c:url var="versioningSchemeUrl" value="https://reactjs.org/blog/2016/02/19/new-versioning-scheme.html"/>
<c:url var="derivedStateNecessityUrl" value="derived-state-necessity"/>
<c:url var="newMethodSignaturesUrl" value="https://gist.github.com/gaearon/88634d27abbc4feeb40a698f760f3264"/>
<c:url var="prefetchDataUrl" value="https://gist.github.com/bvaughn/89700e525ff423a75ffb63b1b1e30a8f"/>
<c:url var="jsConfIcelandUrl" value="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html"/>
<c:url var="createUbscriptionUrl" value="https://github.com/facebook/react/tree/master/packages/create-subscription"/>
<c:url var="exampleUrl" value="https://gist.github.com/bvaughn/d569177d70b50b58bff69c3c4a5353f3"/>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page async-rendering-update-page">
    <h1>Информация по асинхронной отрисовке компонентов</h1>

    <wg:p><b>27 Марта, 2018. Brian Vaughn (Брайан Вон)</b></wg:p>
    
    <wg:p>
        Уже более года команда React работает над реализацией асинхронной отрисовки.
        Теперь мы хотели бы поделиться с вами некоторыми уроками, которые усвоили, работая над этими функциями,
        а также некоторыми рекомендациями, которые помогут подготовить ваши компоненты для асинхронной
        отрисовки, когда она будет активирована.
    </wg:p>
    
    <wg:p>
        Один из самых больших уроков, который мы усвоили, заключается в том, что некоторые из наших устаревших методов
        жизненного цикла компонента, склонны поощрять небезопасные практики кодирования. Это:
    </wg:p>
    
    <wg:p>
        <ul>
            <li><code>componentWillMount</code></li>
            <li><code>componentWillReceiveProps</code></li>
            <li><code>componentWillUpdate</code></li>
        </ul>
    </wg:p>
    
    <p>
        Эти методы жизненного цикла часто понимались неправильно и злоупотреблялись. Более того, мы
        ожидаем, что их потенциальное злоупотребление может принести еще больше проблем вместе с асинхронной
        отрисовкой. Из-за этого мы добавим префикс <b>«UNSAFE_»</b> к данным методам в предстоящей версии. (Здесь
        префикс <b>«UNSAFE_»</b> относится не к безопасности. Он сообщает, что код, использующий данные методы, будет с
        большей вероятностью иметь ошибки в будущих версиях React, особенно после активации асинхронной отрисовки.)
    </p>

    <br/>
    <h2>Путь постепенной миграции</h2>
    
    <p><a href="${versioningSchemeUrl}">React следует схеме управления версиями</a>, поэтому
        данное изменение будет постепенным. Наш текущий план:</p>

    <p>
        <ul>
            <li><b>Релиз 16.3</b>: Вводит псевдонимы/алиасы для небезопасных методов жизненного цикла,
                <code>UNSAFE_componentWillMount</code>, <code>UNSAFE_componentWillReceiveProps</code> и
                <code>UNSAFE_componentWillUpdate</code>. (В данном релизе будут работать и старые имена методов жизненного
                цикла, и новые псевдонимы.)
            </li>
            <li><b>Будущие релизы 16.x</b>: Будут включать предупреждение об устаревании
                методов <code>componentWillMount</code>, <code>componentWillReceiveProps</code> и <code>componentWillUpdate</code>.
                (В данных релизах будут работать и старые имена методов жизненного цикла, и
                новые псевдонимы, но старые имена будут выводить предупреждение в режиме разработки.)
            </li>
            <li><b>Релиз 17.0</b>: Удалит методы <code>componentWillMount</code>,
                <code>componentWillReceiveProps</code> и <code>componentWillUpdate</code>.
                (С того момента будут работать только новые <code>UNSAFE_</code> имена методов жизненного цикла).
            </li>
        </ul>
    </p>

    <p>
        <b>Обратите внимание: если вы являетесь разработчиком приложения React, вам не нужно ничего делать в
            отношении устаревших методов. Главная цель предстоящего релиза версии 16.3 заключается в том, чтобы
            позволить разработчикам проектов с открытым исходным кодом обновлять свои библиотеки до возникновения
            любых предупреждений об устаревании. Данные предупреждения не будут активированы вплоть до следующего
            выпуска 16.x.
        </b>
    </p>

    <p>
        Мы поддерживаем более 50 000 компонентов React в Facebook, и мы не планируем сразу их всех переписывать.
        Мы понимаем, что миграция требует времени. Мы будем проходить постепенный путь миграции
        вместе со всеми в сообществе React.
    </p>

    <br/>
    <h2>Миграция с устаревших методов жизненного цикла</h2>

    <p>
        Если вы хотите начать использовать новый API компонентов, представленный в React 16.3
        (или если вы являетесь разработчиком, который хочет обновить свою библиотеку заранее),
        вот несколько примеров, которые, как мы надеемся, помогут вам посмотреть на компоненты
        под другим углом. Со временем мы планируем добавить дополнительные «рецепты» к нашей
        документации, которые покажут, как можно выполнять общие задачи таким образом, чтобы можно было избежать
        использования проблемных методов жизненного цикла.
    </p>

    <p>Прежде чем мы начнем, кратко рассмотрим изменения жизненного цикла, запланированные для версии 16.3:</p>

    <p>
        <ul>
            <li>Мы <b>добавляем следующие псевдонимы методов жизненного цикла</b>: <code>UNSAFE_componentWillMount</code>,
                <code>UNSAFE_componentWillReceiveProps</code> и <code>UNSAFE_componentWillUpdate</code>. (Будут поддерживаться
                        как старые имена методов жизненного цикла, таки и новые псевдонимы.)
            </li>
            <li>Мы <b>представляем два новых метода жизненного цикла</b>:
                статические <code>getDerivedStateFromProps</code> и <code>getSnapshotBeforeUpdate</code>.
            </li>
        </ul>
    </p>

    <br/>
    <h3>Новый метод жизненного цикла: getDerivedStateFromProps</h3>
    <br/>

    <ce:code-example-1 />

    <p>
        Новый статический метод жизненного цикла <code>getDerivedStateFromProps</code> запускается
        после создания экземпляра компонента, перед его повторной отрисовкой. Он может
        вернуть объект для обновления состояния <code>state</code> или <code>null</code>, чтобы указать, что новые
        свойства <code>props</code> не требуют каких-либо обновлений состояния <code>state</code>.
    </p>

    <p>
        Вместе с <code>componentDidUpdate</code> данный новый метод жизненного цикла должен охватывать
        все случаи использования устаревшего <code>componentWillReceiveProps</code>.
    </p>

    <app:alert type="warning" title="Внимание!">
        Как устаревший <code>componentWillReceiveProps</code>, так и новый <code>getDerivedStateFromProps</code>
        методы придают значительную сложность компонентам. Это часто приводит к ошибкам.
        Рассмотрим <a href="${derivedStateNecessityUrl}"><b>более простые альтернативы
        производному состоянию</b></a>, чтобы сделать компоненты предсказуемыми и поддерживаемыми.
    </app:alert>

    <br/>
    <h3>Новый метод жизненного цикла: getSnapshotBeforeUpdate</h3>
    <br/>

    <p>
        Новый метод жизненного цикла <code>getSnapshotBeforeUpdate</code> вызывается непосредственно перед
        произведением мутаций (например, перед обновлением DOM). Возвращаемое значение для данного
        метода жизненного цикла будет передано в качестве третьего параметра в <code>componentDidUpdate</code>.
        (Данный метод жизненного цикла нужен не так часто, но может быть полезен в таких случаях,
        как ручное сохранение положения прокрутки во время перерисовок).
    </p>

    <p>
        Вместе с <code>componentDidUpdate</code> данный новый метод жизненного цикла должен охватывать
        все случаи использования устаревшего <code>componentWillUpdate</code>.
    </p>

    <p>
        <a href="${newMethodSignaturesUrl}"><b>Вы можете найти их сигнатуры здесь.</b></a>
    </p>

    <p>Далее мы рассмотрим примеры использования данных методов ЖЦ.</p>

    <br/>
    <h2>Примеры</h2>

    <p>
        <ul>
            <li><a href="#e1"><b>Инициализация состояния</b></a></li>
            <li><a href="#e2"><b>Получение внешних данных</b></a></li>
            <li><a href="#e3"><b>Добавление слушателей событий (или подписок)</b></a></li>
            <li><a href="#e4"><b>Обновление состояния state на основе свойств props</b></a></li>
            <li><a href="#e5"><b>Вызов внешних коллбэков</b></a></li>
            <li><a href="#e6"><b>Побочные эффекты при изменении свойств props</b></a></li>
            <li><a href="#e7"><b>Получение внешних данных при изменении свойств props</b></a></li>
            <li><a href="#e8"><b>Чтение свойств DOM перед обновлением</b></a></li>
        </ul>
    </p>

    <br/>
    <app:alert type="warning" title="Внимание!">
        Для краткости приведенные ниже примеры написаны с использованием трансформации
        экспериментальных свойств класса, но те же стратегии миграции применимы и без этого.
    </app:alert>

    <br/>
    <a name="e1"></a>
    <h3>Инициализация состояния</h3>

    <p>В данном примере показан компонент с вызовом <code>setState</code>
        внутри <code>componentWillMount</code>:</p>

    <ce:code-example-3/>

    <p>Простейшим рефакторингом для такого случая является перенос
        инициализации состояния в конструктор или инициализатор свойств, например:</p>

    <ce:code-example-4/>

    <br/>
    <a name="e2"></a>
    <h3>Получение внешних данных</h3>

    <p>Ниже приведен пример компонента, который использует
        <code>componentWillMount</code> для извлечения внешних данных:</p>

    <ce:code-example-5/>

    <p>Вышеприведенный код проблематичен как для серверной отрисовки (где внешние данные не
        будут использоваться), так и для предстоящего режима асинхронной отрисовки (где запрос
        может быть инициирован множество раз).</p>

    <p>Рекомендуемый путь апгрэйда для большинства ситуаций - это перенос
        логики извлечения данных в <code>componentDidMount</code>:</p>

    <ce:code-example-6/>

    <p>Существует распространенное заблуждение, что логика извлечения данных в
        <code>componentWillMount</code> позволяет избежать отображения пустого состояния при первой отрисовке.
        На практике это никогда не соответствовало действительности, потому что React всегда выполнял
        отрисовку сразу после <code>componentWillMount</code>. Если данные не доступны к моменту
        срабатывания <code>componentWillMount</code>, первая отрисовка будет по-прежнему показывать
        состояние загрузки независимо от того, где вы инициируете извлечение данных. Вот
        почему перенос <code>fetch</code> в <code>componentDidMount</code> не дает ощутимой разницы в подавляющем
        большинстве случаев.</p>

    <br/>
    <app:alert type="warning" title="Внимание!">
        В некоторых продвинутых случаях использования (например, библиотеки, такие как Relay), возможно,
        захочется поэкспериментировать с предварительной асинхронной выборкой данных. Пример того,
        как это можно сделать, <b><a href="${prefetchDataUrl}">доступен здесь</a></b>.
        <br/><br/>
        В более долгосрочной перспективе канонический способ получения данных в компонентах React,
        скорее всего, будет основан на API-интерфейсе <b>«приостановка»</b>, представленном
        на <a href="${jsConfIcelandUrl}"><b>JSConf Iceland</b></a>. Как решения по простому извлечению
        данных, так и библиотеки, такие как Apollo или Relay,
        смогут использовать его у себя под капотом. Он наименее многословен, чем любое из
        вышеперечисленных решений, но, к сожалению, не будет завершен к моменту выпуска 16.3.
        <br/><br/>
        В настоящее время при поддержке отрисовки на сервере необходимо предоставлять данные
        синхронно - ранее для этой цели часто использовался <code>componentWillMount</code>, но в качестве
        замены можно использовать и конструктор. Предстоящий API-интерфейс приостановки сделает
        асинхронную выборку данных возможной (и в аккуратной форме) как для серверной, так и для клиентской отрисовок.
    </app:alert>

    <br/>
    <a name="e3"></a>
    <h3>Добавление слушателей событий (или подписок)</h3>

    <p>Ниже приведен пример компонента, который подписывается на диспетчер внешних событий при монтировании:</p>

    <ce:code-example-7/>

    <p>К сожалению, это может привести к утечкам памяти как для случая отрисовки на сервере
        (где <code>componentWillUnmount</code> никогда не будет вызван), так и для асинхронной отрисовки
        (где отрисовка может быть прервана до своего завершения, в результате чего
        <code>componentWillUnmount</code> не будет вызван).</p>

    <p>Люди часто предполагают, что <code>componentWillMount</code> и <code>componentWillUnmount</code> всегда сопряжены,
        но это не гарантируется. Только единожды, после того как был вызван <code>componentDidMount</code>,
        React гарантирует, что <code>componentWillUnmount</code> будет вызван позже для очистки.</p>

    <p>По этой причине рекомендуемым способом добавления слушателей/подписок является
        использование метода жизненного цикла <code>componentDidMount</code>:</p>

    <ce:code-example-8/>

    <p>Иногда важно обновлять подписки в ответ на изменения свойств. Если вы используете
        библиотеку, такую как <b>Redux</b> или <b>MobX</b>, компонент-контейнер библиотеки должен обрабатывать
        это за вас. Для разработчиков приложений мы создали небольшую библиотеку,
        <a href="${createUbscriptionUrl}"><b>create-subscription</b></a>,
        чтобы помочь с этим. Мы опубликуем ее вместе с React 16.3.</p>

    <ce:code-example-9/>

    <app:alert type="warning" title="Внимание!">
        Библиотекам, таким как <b>Relay/Apollo</b>, следует вручную управлять подписками с помощью
        тех же методов, что и <a href="${createUbscriptionUrl}"><b>create-subscription</b></a> использует у
        себя под капотом (как показано <a href="${exampleUrl}"><b>здесь</b></a>), а также таким образом, который наиболее оптимален
        для использования в данной библиотеке.
    </app:alert>

    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
</lt:layout>

<c:url var="prevPageUrl" value="react-v16.4.0-pointer-events"/>
<app:page-navigate pageStartAncor="pageStart" prevPageUrl="${prevPageUrl}"/>