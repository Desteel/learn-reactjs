<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/faq/file-structure" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>

<c:url var="classnamesUrl" value="https://www.npmjs.com/package/classnames"/>
<c:url var="atomicWebDesignUrl" value="http://bradfrost.com/blog/post/atomic-web-design/"/>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page file-structure">
  <h1>Структура файлов</h1>

  <br/>
  <h3>Существует ли рекомендованный способ структурировать проекты React?</h3>

  <wg:p>
    React не имеет отношения к тому, как вы располагаете файлы в папках. Тем не менее,
    существует несколько общих подходов, популярных в экосистеме, которые вы, возможно, захотите рассмотреть.
  </wg:p>

  <br/>
  <h4>Группирование по функции или маршруту.</h4>

  <wg:p>
    Одним из распространенных способов структурирования проектов является размещение
    CSS, JS и тестов вместе внутри папок, сгруппированных по функции или маршруту.
  </wg:p>

  <ce:code-example-1/>

  <wg:p>
    Определение «функция» не является универсальным, и вся детализация остается за вами.
    Если вы не можете определить список папок верхнего уровня, вы можете спросить пользователей
    вашего продукта, из каких основных частей он состоит, и использовать их мысленную модель в качестве плана.
  </wg:p>

  <br/>
  <h4>Группирование по типу файлов.</h4>

  <wg:p>
    Другим популярным способом структурирования проектов является группировка
    похожих файлов, например:
  </wg:p>

  <ce:code-example-2/>

  <wg:p>
    Некоторые люди также предпочитают идти дальше и поместить компоненты в различные
    папки в зависимости от их роли в приложении. Например,
    <wg:link href="${atomicWebDesignUrl}">Atomic Design</wg:link> - это методология
    проектирования, построенная на данном принципе. Помните, что часто полезнее рассматривать
    такие методологии как полезные примеры, а не как строгие правила.
  </wg:p>

  <br/>
  <h4>Избежание большой вложенности.</h4>

  <wg:p>
    Существует много неприятных моментов, связанных с большой вложенностью каталогов в
    проектах JavaScript. Становится сложнее писать относительный импорт между ними или
    обновлять эти импорты при перемещении файлов. Если у вас нет убедительной причины
    использовать глубокую структуру каталогов, подумайте о том, чтобы ограничить себя
    <b>максимум тремя или четырьмя</b> уровнями вложенности каталогов в рамках одного проекта.
    Конечно, это только рекомендация, которая может быть не актуальна для вашего проекта.
  </wg:p>

  <br/>
  <h4>Не переусердствуйте!</h4>

  <wg:p>
    Если вы только начинаете проект, не тратьте более пяти минут на выбор файловой структуры.
    Выберите любой из вышеуказанных подходов (или придумайте свой собственный) и начните
    писать код! Вероятно, вы захотите переосмыслить структуру, написав какой-нибудь реальный код.
  </wg:p>

  <wg:p>
    Если вы окончательно застряли, начните с хранения всех файлов в одной папке. В конце концов,
    она станет настолько большой, что вам захочется отделить некоторые файлы от остальных.
    К тому времени у вас будет достаточно знаний, чтобы точно определить, какие файлы вы редактируете вместе
    чаще всего. В целом, файлы, которые часто изменяются вместе, рекомендуется хранить друг с
    другом в одной папке. Этот принцип называется <b>«colocation»</b>(совместное расположение).
  </wg:p>

  <wg:p>
    На практике по мере своего роста проекты часто используют сочетание обоих вышеупомянутых подходов.
    Поэтому выбор «правильного» в самом начале не очень важен.
  </wg:p>
</lt:layout>

<c:url var="prevPageUrl" value="styling-and-css"/>
<c:url var="nextPageUrl" value="virtual-dom-and-internals"/>
<app:page-navigate prevPageUrl="${prevPageUrl}"
                   pageStartAncor="pageStart"
                   nextPageUrl="${nextPageUrl}"/>