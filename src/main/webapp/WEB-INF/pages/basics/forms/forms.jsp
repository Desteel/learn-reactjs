<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/basics/forms" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>
<%@taglib prefix="ad" tagdir="/WEB-INF/tags/application/advertising" %>

<a name="pageStart"></a>
<div class="black-line"></div>
<div class="page forms-page">
    <h1>2.10 Формы</h1>

    <p class="introduction">
        Работа элементов HTML-форм в React немного отличается от работы других DOM-элементов.
        Это связано с тем, что элементы форм по своей природе обладают некоторым внутренним состоянием. К примеру,
        данная форма в нативном HTML принимает только имя:
    </p>

    <ce:code-example-1/>

    <p>
        Представленная форма имеет поведение HTML-формы по умолчанию: <b>просмотр новой страницы, когда
        пользователь посылает форму.</b> Если такое поведение вам необходимо и в React, то оно работает
        как обычно. Но в большинстве случаев нам удобно иметь JavaScript-функцию, которая <b>имеет доступ
        к данным, которые пользователь ввел в форму</b> и <b>обрабатывает её отправку</b>.
        Для этой цели, есть стандартный подход, под названием «контролируемые компоненты».
    </p>

    <a name="controlled-components"></a>
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>2.10.1 Контролируемые компоненты</h2>
    <br/>

    <p>По умолчанию в HTML элементы формы, такие как <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>
        и <code>&lt;select&gt;</code>, хранят свое собственное состояние и обновляют
        его на основании пользовательского ввода. Но в React модифицируемое состояние, как правило,
        является собственностью компонентов и обновляется только с помощью <code>setState()</code>.</p>

    <p>Мы можем скомбинировать обе эти особенности, делая состояние React “<b>единственным источником
        достоверной информации (истины)</b>”. В свою очередь React-компонент, который отрисовывает форму,
        также контролирует, что происходит на этой форме в ответ на последующий ввод пользователя.
        Элемент ввода формы (например, <code>input</code>), значение которого контролируется React, в этом случае
        называется <b>«контролируемый компонент»</b>.</p>

    <p>К примеру, если в предыдущем примере мы хотим делать лог имени, когда форма отправляется, мы можем написать
        форму как контролируемый компонент:</p>

    <ce:code-example-2 codePenUrl="https://codepen.io/stzidane/pen/mwbBmM?editors=0010"/>

    <p>
        Как только на элементе формы c <code>name="login"</code> изменяется атрибут <code>value</code>,
        срабатывает <code>onChangeLogin</code>, изменяя значение состояния компонента <code>this.state.login</code>.
        Далее происходит перерисовка. Таким образом отображаемое значение всегда будет равно <code>this.state.login</code>,
        делая состояние React единственным источником достоверной информации. Когда пользователь что-нибудь печатает,
        обработчик <code>onChangeLogin</code> срабатывает на каждое нажатие клавиши, изменяя состояние компонента, что
        в свою очередь приводит к обновлению значения на экране.
    </p>
    
    <ad:ad-content-banner-1/>

    <p>В подходе <b>«контролируемый компонент»</b>, любая модификация состояния имеет соответствующий обработчик.
        Это делает простым изменение или проверку данных, вводимых пользователем. К примеру, если мы
        хотим, чтобы логин вводился только в верхнем регистре, мы можем написать <code>onChangeLogin</code> как:</p>

    <ce:code-example-3/>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>2.10.2 Тег textarea</h2>
    <br/>

    <p>В нативном HTML элемент <code>&lt;textarea&gt;</code> определяет введенный в него текст по его потомкам:</p>

    <ce:code-example-4/>

    <p>В React элемент <code>&lt;textarea&gt;</code> вместо потомков использует значение атрибута <code>value</code> и
        в коде ничем не отличается однострочного элемента <code>input</code>:

    <ce:code-example-5 codePenUrl="https://codepen.io/stzidane/pen/owXvyN?editors=0010"/>

    <p>Обратите внимание, что <code>this.state.value</code> инициализируется в конструкторе,
        поэтому <code>textarea</code> показывается уже с некоторым текстом.</p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>2.10.3 Тег select</h2>
    <br/>

    <p>
        В нативном HTML тег <code>&lt;select&gt;</code> создает выпадающий список. К примеру
        данный HTML создает выпадающий список языков программирования:
    </p>

    <ce:code-example-6/>

    <p>
        Обратите внимание, что по умолчанию выбрана опция “JavaScript”, так как задан
        атрибут <code>selected</code>. React вместо атрибута <code>selected,</code>
        использует атрибут <code>value</code> на корневом теге <code>select</code>. В контролируемом
        компоненте это удобнее, потому что этот атрибут нужно обновлять только в
        одном месте. Например:
    </p>

    <ce:code-example-7 codePenUrl="https://codepen.io/stzidane/pen/owXvRj?editors=0010"/>

    <p>
        В целом, это делает поведение тегов <code>&lt;input type="text"&gt;</code>,
        <code>&lt;textarea&gt;</code> и <code>&lt;select&gt;</code> очень похожим –
        они все принимают атрибут <code>value</code>, который вы можете использовать, чтобы
        реализовать контролируемый компонент.
    </p>

    <p>
        Также в атрибут <code>value</code> вы можете передать массив. Это позволяет выбрать
        в теге <code>select</code> сразу несколько опций.
    </p>

    <ce:code-example-8/>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>2.10.4 Тег input типа file</h2>
    <br/>

    <p>В нативном HTML тег <code>&lt;input type="file"/&gt;</code> позволяет пользователю выбирать один
        или несколько файлов из хранилища своего устройства для загрузки на
        сервер, а также манипулировать собой с помощью JavaScript через File API.</p>

    <ce:code-example-8.1/>

    <p>
        Поскольку его значение доступно только для чтения, это неконтролируемый компонент
        в React. Он обсуждается вместе с другими неконтролируемыми компонентами
        позже в документации.
    </p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>2.10.5 Обработка множества input</h2>
    <br/>

    <p>Когда вам нужно обрабатывать множество контролируемых элементов <code>input</code>,
        вы можете добавить атрибут <code>name</code> на каждый элемент и позволить
        функции-обработчику выбрать, что делать, на основании значения <code>event.target.name</code>.</p>

    <p>Например:</p>

    <ce:code-example-9 codePenUrl="https://codepen.io/stzidane/pen/YQXzpZ?editors=0010"/>

    <p>Обратите внимание на то, как мы использовали синтаксис ES6 <b>вычисляемого имени свойства</b>,
        чтобы обновить ключ состояния в соответствии с данным именем тега <code>input</code>:</p>

    <ce:code-example-10/>

    <p>Это эквивалент данного ES5 кода:</p>

    <ce:code-example-11/>

    <p>Поскольку <code>setState()</code> делает слияние частичного состояния в
        текущее автоматически, нам лишь нужно вызывать его с изменившейся частью.</p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>2.10.5 Пустое значение атрибута value контролируемого input</h2>
    <br/>

    <p>
        Если вы укажете значение этого атрибута на контролируемом компоненте, то пользователь не сможет
        его изменять. Если вы указали <code>value</code>, но <code>input</code> все еще редактируемый, вы
        могли случайно установить <code>value</code> в <code>undefined</code> или <code>null</code>.
    </p>

    <p>Следующий код демонстрирует это. (Сначала <code>input</code> заблокирован, но становится
        редактируемым после короткой задержки.)</p>

    <ce:code-example-12/>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>2.10.6 Альтернативы контролируемым компонентам</h2>
    <br/>

    <c:url var="uncontrolledComponentsUrl" value="/core/uncontrolled-components"/>
    <p>
        Для многих использовать контролируемые компоненты бывает утомительно. Ведь вам необходимо
        написать обработчик для каждого случая изменения ваших
        данных и пропустить все состояния <code>input</code>-ов через React-компонент. Это может
        сильно раздражать, когда вы переписываете предшествующую кодовую базу на React,
        или интегрируете React-приложение с не-React библиотекой. В таких ситуациях вам,
        возможно, стоит рассмотреть <b><a href="${uncontrolledComponentsUrl}">неконтролируемые компоненты</a></b>,
        как альтернативный метод реализации форм ввода.
    </p>
</div>

<c:url var="prevPageUrl" value="lists-and-keys"/>
<c:url var="nextPageUrl" value="lifting-state-up"/>
<app:page-navigate prevPageUrl="${prevPageUrl}"
                   pageStartAncor="pageStart"
                   nextPageUrl="${nextPageUrl}"/>