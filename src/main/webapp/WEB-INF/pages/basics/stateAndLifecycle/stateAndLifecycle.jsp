<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/basics/state-and-lifecycle" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>
<%@taglib prefix="ad" tagdir="/WEB-INF/tags/application/advertising" %>

<c:url var="granularDomUpdatesUrl" value="/resources/imges/pages/basics/render-elements/granular-dom-updates.gif"/>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page hello-world-example-page">
    <h1>2.6 Состояние и жизненный цикл</h1>

    <c:url var="referenceUrl" value="/reference/react-component"/>
    
    <p class="introduction">
        В этом разделе мы расскажем о таких важных концепциях, как состояние
        и жизненный цикл компонента React. Более подробный API компонента
        вы можете найти <b><a href="${referenceUrl}">здесь</a></b>.
    </p>

    <br/>

    <p>Рассмотрим, упомянутый ранее, пример тикающих часов.</p>

    <p>Пока что мы знаем только один способ обновления UI.</p>

    <p>Мы вызываем <code>ReactDOM.render()</code>, чтобы изменить результат отрисовки:</p>

    <ce:code-example-1 codePenUrl="https://codepen.io/stzidane/pen/QgWgNP?editors=0010"/>

    <p>В этом разделе мы сделаем компонент <code>Timer</code> по-настоящему переиспользуемым и
        инкапсулированным. Он сначала установит собственный таймер, а затем станет периодически обновляться 
        через определенный промежуток времени.</p>

    <p>Давайте начнём с инкапсуляции кода в компонент <code>Timer</code>:</p>

    <ce:code-example-2 codePenUrl="https://codepen.io/stzidane/pen/yXLXKY?editors=0010"/>

    <p>
        Прекрасно! Однако мы пока не учли ключевое требование: установка таймера и обновление UI
        каждую секунду должны быть деталью реализации <code>Timer</code>.
    </p>
    
    <p>
        В идеале, нам необходимо спроектировать самообновляющийся компонент <code>Timer</code> так, чтобы код, который его 
        использует имел следующий вид:
    </p>

    <ce:code-example-3/>

    <p>
        Чтобы этого добиться, к компоненту <code>Timer</code> нужно добавить <b>состояние</b>.
    </p>

    <p>Состояние похоже на свойства <b>props</b>, однако является приватным и полностью контролируется компонентом.</p>
    
    <ad:ad-content-banner-1/>

    <c:url var="hooksUrl" value="/core/hooks/topics"/>

    <p>Раньше состоянием могли обладать только компоненты-классы.
        Однако с появлением <b><a href="${hooksUrl}">хуков</a></b> состоянием могут обладать и компоненты-функции.</p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>2.6.1 Преобразование функций в классы</h2>
    <br/>

    <p>Мы можем преобразовать компонент-функцию <code>Timer</code> в класс за пять шагов:</p>

    <ol>
        <li>Создать одноимённый ES6-класс, который расширяет <code>React.Component</code>.</li>
        <li>Добавить в него единственный пустой метод под названием <code>render()</code>.</li>
        <li>Поместить тело функции в метод <code>render()</code>.</li>
        <li>Заменить <code>props</code> на <code>this.props</code> в теле метода <code>render()</code>.</li>
        <li>Удалить оставшееся пустое определение функции</li>
    </ol>

    <ce:code-example-4 codePenUrl="https://codepen.io/stzidane/pen/xrxrQP?editors=0010"/>

    <p>Теперь компонент <code>Timer</code> определён как класс, а не как функция.</p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>2.6.2 Добавление локального состояния в класс</h2>
    <br/>

    <p>Давайте переместим <code>date</code> из <code>props</code> в <code>state</code> в три этапа.</p>

    <p>1. Заменим <code>this.props.value</code> на <code>this.state.value</code> в методе <code>render()</code>:</p>

    <ce:code-example-5/>

    <p>2. Добавим конструктор класса, который устанавливает начальное состояние <code>this.state</code>:</p>

    <ce:code-example-6/>

    <p>Обратите внимание на то, как мы передаем свойства <code>props</code> в базовый конструктор:</p>

    <ce:code-example-7/>

    <p><b>Компоненты-классы должны всегда вызывать базовый конструктор с</b> <code>props</code>.</p>

    <p>3. Удаляем свойство <code>value</code> из <code>&lt;Timer /&gt;</code> элемента:</p>

    <ce:code-example-8/>

    <p>Позже мы добавим код таймера обратно в сам компонент.</p>

    <p>Результат будет выглядеть следующим образом:</p>

    <ce:code-example-9 codePenUrl="https://codepen.io/stzidane/pen/GERvKL?editors=0010"/>

    <p>
        Далее мы сделаем так, что компонент <code>Timer</code> будет
        устанавливать таймер и обновлять себя каждую секунду.
    </p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>2.6.3 Добавление методов жизненного цикла в класс</h2>
    <br/>

    <p>
        При старте приложения React, компонент <code>Timer</code> будет впервые отрисован в DOM.
        В React это называется <b>монтированием/монтажом</b> компонента.
    </p>

    <p>
        Обратная процедура, при которой DOM, созданный компонентом <code>Timer</code>,
        удаляется, называется <b>демонтированием/демонтажём</b>.
    </p>

    <p>
        После каждого монтирования <code>Timer</code> ему нужно устанавливать
        таймер, чтобы периодически себя обновлять.
    </p>

    <p>
        Однако в приложениях с множеством компонентов очень важно высвобождать ресурсы,
        занятые компонентами, когда они уничтожаются, чтобы избежать утечек памяти.
    </p>

    <p>
        В нашем случае таймер - это ресурс и нам нужно очищать
        его перед каждым демонтированием компонента.
    </p>

    <p>React позволяет объявить в компоненте-классе специальные методы, чтобы запускать определенный
        код, когда компонент монтируется или демонтируется:</p>

    <ce:code-example-10/>

    <p>В документации эти методы носят название «<b>lifecycle hooks</b>». Мы же для простоты
        будем называть их методами жизненного цикла.</p>

    <p>Метод <code>componentDidMount()</code> срабатывает после того, как
        компонент был впервые отрисован в DOM - монтирован. Это отличное место, чтобы установить таймер:</p>

    <ce:code-example-11/>

    <p>Обратите внимание, как мы сохраняем ID таймера прямо в <code>this</code>.</p>

    <p>В то время как React самостоятельно устанавливает свойства <code>this.props</code>, а
        <code>this.state</code> имеет определенное значение, вы можете вручную добавить в класс
        дополнительные поля, если вам нужно хранить что-то, что не используется для результата отрисовки.</p>

    <p>Если вы не используете что-то в <code>render()</code>, оно не должно
        находиться в состоянии <code>state</code>.</p>

    <p>Мы будем очищать таймер в методе жизненного цикла <code>componentWillUnmount()</code>:</p>

    <ce:code-example-12/>

    <p>Далее, мы реализуем метод <code>increment()</code>, который будет выполняться каждую секунду.</p>

    <p>Он будет использовать <code>this.setState()</code>, чтобы планировать обновления
        в локальном состоянии компонента:</p>

    <ce:code-example-13 codePenUrl="https://codepen.io/stzidane/pen/vZYJLP?editors=0010"/>

    <p>Теперь компонент постоянно обновляется через установленный промежуток времени.</p>
    
    <ad:ad-content-banner-2/>

    <p>Давайте подытожим всё, что произошло, а также порядок, в котором вызываются методы:</p>

    <ol>
        <li>
            <p>
                Когда <code>&lt;Timer/&gt;</code> передан в <code>ReactDOM.render()</code>, React вызывает
                конструктор компонента <code>Timer</code>. Как только <code>Timer</code> нуждается в
                отображении текущего значения, он инициализирует <code>this.state</code> объектом,
                включающим текущее значение таймера. Позже мы обновим это состояние.
            </p>

        </li>

        <li>
            <p>
                Далее React вызывает метод <code>render()</code> компонента <code>Timer</code>. Возвращаемый им результат - это то,
                как React понимает, что должно быть отображено на экране. Далее React обновляет DOM, в
                соответствии с результатом отрисовки <code>Timer</code>.
            </p>
        </li>

        <li>
            <p>
                Когда результат отрисовки <code>Timer</code> вставлен в DOM, React вызывает
                метод <code>componentDidMount()</code> жизненного цикла. Внутри него компонент
                <code>Timer</code> обращается к браузеру для установки таймера, чтобы
                вызывать <code>increment()</code> раз в секунду.
            </p>
        </li>

        <li>
            <p>
                Браузер вызывает метод <code>increment()</code> каждую секунду. Внутри него компонент <code>Timer</code>
                планирует обновление UI с помощью вызова <code>setState()</code> с объектом,
                содержащим текущее время. Благодаря вызову <code>setState()</code>, React знает, что состояние
                изменилось, и вызывает метод <code>render()</code> снова, чтобы узнать, что должно быть на экране.
                Значение <code>this.state.value</code> в методе <code>render()</code> будет отличаться, поэтому результат
                отрисовки будет содержать обновленное значение таймера. React обновляет DOM соответственно.
            </p>
        </li>

        <li>
            <p>
                Если компонент <code>Timer</code> в какой-то момент удалён из DOM, React вызывает
                метод <code>componentWillUnmount()</code> жизненного цикла, из-за чего таймер останавливается.
            </p>
        </li>
    </ol>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>2.6.4 Корректное обновление состояния</h2>
    <br/>

    <p>Необходимо знать <b>три вещи</b> о <code>setState()</code>.</p>

    <br/>
    <h3>2.6.4.1 Не модифицируйте состояние напрямую</h3>

    <p>К примеру, этот компонент не будет перерисовывать сам себя:</p>

    <ce:code-example-14/>

    <p>Для корректной модификации состояния компонента используйте метод <code>setState()</code>:</p>

    <ce:code-example-15/>

    <app:alert title="Внимание!" type="warning">
        Вы можете установить <code>this.state</code> только в конструкторе!
    </app:alert>

    <br/>
    <h3>2.6.4.2 Обновления состояния могут быть асинхронными</h3>

    <p>
        React может собирать последовательность вызовов <code>setState()</code> в единое обновление
        в целях повышения производительности.
    </p>

    <p>Так как React может обновлять <code>this.props</code> и <code>this.state</code> асинхронно,
        вы не должны полагаться на их значения для вычисления следующего состояния.</p>

    <p>К примеру, такой код может не обновить температуру:</p>

    <ce:code-example-16/>

    <p>Для того, чтобы это исправить, используйте следующую форму метода <code>setState()</code>, который
        принимает функцию, вместо объекта. Эта функция будет принимать предыдущее состояние как первый
        аргумент и свойства в момент обновления как второй аргумент.</p>

    <ce:code-example-17/>

    <p>Мы использовали стрелочную функцию, но можно использовать и обычные функции:</p>

    <ce:code-example-18/>

    <br/>
    <h3>2.6.4.3 Обновления состояния объединяются</h3>

    <p>Когда вы вызываете <code>setState()</code>, React производит
        объединение(слияние) текущего состояния и объекта, который вы предоставили.</p>

    <p>Например, состояние вашего компонента может содержать множество независимых переменных:</p>

    <ce:code-example-19/>

    <p>Далее вы можете обновить их независимо с помощью отдельных вызовов <code>setState()</code>:</p>

    <ce:code-example-20/>

    <p>Объединение неглубокое, поэтому <code>this.setState({users})</code> оставляет <code>this.state.permissions</code>
        нетронутым, но полностью заменяет <code>this.state.users</code>.</p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>2.6.5 Нисходящий поток данных</h2>
    <br/>

    <p>О наличии состояния у определенного компонента не могут знать ни его родительский, ни дочерний компоненты.
        Более того - они даже не знают, каким образом определен компонент: с помощью функции или класса.</p>

    <p>Вот почему состояние часто называют <b>локальным</b> или <b>инкапсулированным</b>.
        Оно недоступно для какого-либо компонента, за исключением того, который им владеет и устанавливает.</p>

    <p>Компонент может решить передать это состояние вниз как свойства
        <code>props</code> своим дочерним компонентам:</p>

    <ce:code-example-21/>

    <p>Таким же образом это работает и для пользовательских компонентов:</p>

    <ce:code-example-22/>

    <p>Компонент <code>ClockFace</code> хотел бы получать значение <code>value</code> в
        своих свойствах. Ему незачем знать откуда оно пришло: из состояния компонента <code>Timer</code>,
        из свойств компонента <code>Timer</code> или было указано вручную:</p>

    <ce:code-example-23 codePenUrl="https://codepen.io/stzidane/pen/OgJjQM?editors=0010"/>

    <p>Это принято называть «<b>сверху-вниз</b>», «<b>нисходящим</b>» или однонаправленным потоком данных.
        Любое состояние всегда находится во владении какого-либо компонента. Любые данные или UI, производные
        от этого состояния могут передаваться только в компоненты «<b>ниже</b>» их в дереве иерархии.</p>

    <p>Если представить дерево компонентов как «водопад» свойств, то состояние каждого компонента
        является подобием дополнительного источника воды, который соединяется с водопадом в произвольной
        точке и также течет вниз.</p>

    <p>Чтобы показать, что все компоненты действительно изолированы,
        мы можем создать компонент <code>Application</code>, который отрисовывает <code>&lt;Timer/&gt;</code>:</p>

    <ce:code-example-24 codePenUrl="https://codepen.io/stzidane/pen/dRyzKE?editors=0010"/>

    <p>Каждый компонент <code>&lt;Timer/&gt;</code> устанавливает своё собственное значение и
        обновляется независимо.</p>

    <p>В приложениях React, независимо от того, обладает ли компонент состоянием – состояние является
        деталью реализации этого компонента и может изменяться со временем. Вы можете использовать компоненты без
        состояния внутри компонентов, имеющих состояние, и наоборот.</p>
</lt:layout>

<c:url var="prevPageUrl" value="components-and-props"/>
<c:url var="nextPageUrl" value="handling-events"/>
<app:page-navigate prevPageUrl="${prevPageUrl}"
                   pageStartAncor="pageStart"
                   nextPageUrl="${nextPageUrl}"/>