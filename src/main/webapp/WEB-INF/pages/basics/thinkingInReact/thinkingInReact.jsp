<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/basics/thinking-in-react" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>

<c:url var="tableMockUrl" value="https://reactjs.org/static/thinking-in-react-mock-1071fbcc9eed01fddc115b41e193ec11-4dd91.png"/>
<c:url var="separatingUIMockUrl" value="https://reactjs.org/static/thinking-in-react-components-eb8bda25806a89ebdc838813bdfa3601-82965.png"/>
<c:url var="thinkingInReactStep2Url" value="https://codepen.io/gaearon/pen/BwWzwm"/>
<c:url var="thinkingInReactStep4Url" value="https://codepen.io/gaearon/pen/qPrNQZ"/>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page thinking-in-react-page">
    <h1>2.13 Мышление в React</h1>

    <wg:p>React - это, по мнению разработчиков, образцовый путь создания больших,
        быстрых веб-приложений с JavaScript. React очень хорошо масштабируется
        для их нужд в Facebook и Instagram.</wg:p>

    <wg:p>
        Одна из многих замечательных частей React - это то, как вы думаете о
        приложениях по мере их создания. В этом документе мы рассмотрим процесс создания
        таблицы данных продуктов с поиском, используя React.
    </wg:p>

    <br/>
    <h2>2.13.1 Начинаем с макета</h2>

    <wg:p>
        Представьте, что у нас уже есть JSON API и макет нашего дизайнера. Макет выглядит так:
    </wg:p>

    <wg:img src="${tableMockUrl}"/>

    <wg:p>Наш JSON API возвращает некоторые данные, которые выглядят так:</wg:p>

    <ce:code-example-1/>

    <br/>
    <h2>2.13.2 Шаг 1: Разбиение UI на иерархию компонентов</h2>

    <wg:p>
        Первое, что вам нужно сделать, это нарисовать прямоугольники вокруг каждого
        компонента (и подкомпонента) в макете и дать им всем имена. Если вы работаете с дизайнерами, они,
        возможно, уже сделали это, поэтому поговорите с ними! Имена их слоев в Photoshop могут оказаться
        именами ваших компонентов React!
    </wg:p>

    <wg:p>
        Но как вы поймете, каков должен быть компонент? Просто используйте те же самые методы для
        принятия решения, если вам необходимо создать новую функцию или объект. Одним из таких
        методов является принцип единой ответственности, то есть в идеале компонент должен делать
        только что-то одно. Если компонент слишком разрастается, он должен быть разложен на
        меньшие подкомпоненты.
    </wg:p>

    <wg:p>
        Поскольку вы часто показываете модель данных JSON для пользователя, вы обнаружите,
        что если ваша модель была построена правильно, ваш UI (и, следовательно, структура вашего
        компонента) будет отображаться корректно. Это связано с тем, что UI и модели данных имеют
        тенденцию придерживаться одной и той же информационной архитектуры, а это означает, что
        работа по разделению вашего UI на компоненты часто тривиальна. Просто разделите его на
        компоненты, которые представляют собой ровно одну часть вашей модели данных.
    </wg:p>

    <wg:img src="${separatingUIMockUrl}"/>

    <wg:p>
        Здесь видно, что в нашем простом приложении у нас есть пять компонентов. Мы выделим
        курсивом данные, представляемые каждым компонентом.
    </wg:p>

    <wg:p>
        <ul>
            <li>FilterableProductTable (оранжевый): содержит контент примера</li>
            <li>SearchBar (голубой): принимает весь пользовательский ввод</li>
            <li>ProductTable (зеленый): отображает и фильтрует коллекцию данных, основанную на пользовательском вводе</li>
            <li>ProductCategoryRow (бирюзовый): отображает заголовок каждой категории</li>
            <li>ProductRow (красный): отображает строку каждого продукта</li>
        </ul>
    </wg:p>

    <wg:p>
        Если вы посмотрите на <code>ProductTable</code>, вы увидите, что заголовок таблицы (содержащий надписи «Имя» и
        «Цена») сам по себе не является компонентом. Это вопрос предпочтения, и есть аргумент, который нужно
        сделать в любом случае. В этом примере мы оставили его как часть <code>ProductTable</code>, потому что он
        является частью процесса отрисовки коллекции данных, что является ответственностью <code>ProductTable</code>.
        Однако, если этот заголовок становится сложным (т. е. если мы будем добавлять возможности для
        сортировки), было бы разумно сделать его отдельным компонентом <code>ProductTableHeader</code>.
    </wg:p>

    <wg:p>
        Теперь, когда мы определили компоненты в нашем макете, давайте организуем их в иерархию.
        Это легко. Компоненты, которые расположены в другом компоненте в mock, должны
        отображаться как дочерние в иерархии:
    </wg:p>

    <wg:p>
        <ul>
            <li>
                <code>FilterableProductTable</code>
                <ul>
                    <li><code>SearchBar</code></li>
                    <li>
                        <code>ProductTable</code>
                        <ul>
                            <li><code>ProductCategoryRow</code></li>
                            <li><code>ProductRow</code></li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </wg:p>

    <br/>
    <h2>2.13.3 Шаг 2: Построение статической версии в React</h2>

    <wg:p>
        Посмотрите Pen <wg:link href="${thinkingInReactStep2Url}">Thinking In React: Step 2</wg:link> в CodePen.
    </wg:p>

    <wg:p>
        Теперь, когда у вас есть иерархия компонентов, пришло время реализовать ваше приложение.
        Самый простой способ - создать версию, которая берет вашу модель данных и отрисовывает UI, но
        не имеет интерактивности. Лучше всего отделить эти процессы, потому что для создания статической
        версии требуется много печатать и мало думать, а для добавления интерактивности требуется много
        мышления, но не много печатной рутины. Посмотрим, почему.
    </wg:p>

    <wg:p>
        Чтобы создать статическую версию вашего приложения, которое отображает вашу модель данных,
        вы захотите создать компоненты, которые повторно используют другие компоненты и
        передают данные с помощью <code>props</code>. <code>props</code> - это способ передачи данных от родителя потомку.
        Если вы знакомы с концепцией состояния, <b>не используйте состояние вообще</b> для создания этой
        статической версии. Состояние зарезервировано только для интерактивности, то есть данные изменяются с течением времени.
        Поскольку это статическая версия приложения, вам это не нужно.
    </wg:p>

    <wg:p>
        Вы можете начать создавать компоненты сверху вниз или снизу вверх. То есть вы можете начать с построения компонентов,
        находящихся выше в иерархии (то есть с <code>FilterableProductTable</code>) или с более нижних
        (<code>ProductRow</code>). В более простых примерах, как правило, легче идти сверху вниз, а в более крупных проектах
        легче идти снизу вверх и писать тесты по мере создания компонентов.
    </wg:p>

    <wg:p>
        В конце этого шага вы будете иметь библиотеку повторно используемых компонентов, которые
        отображают вашу модель данных. Компоненты будут иметь только методы <code>render()</code>, поскольку
        это статическая версия вашего приложения. Компонент на вершине иерархии (<code>FilterableProductTable</code>)
        будет принимать вашу модель данных через <code>props</code>. Если вы внесете изменения в свою базовую модель
        данных и снова вызовете <code>ReactDOM.render()</code>, UI будет обновлен. Легко понять, как обновляется
        ваш UI и где вносить изменения, так как тут нет ничего сложного. <b>Односторонний поток данных</b>
        React (также называемый <b>односторонней привязкой</b>) сохраняет все модульным и быстрым.
    </wg:p>

    <br/>
    <h3>2.13.3.1 Краткая интерлюдия: Props vs State</h3>

    <wg:p>
        Существует два типа "модельных" данных в React: свойства (<code>props</code>) и состояние (<code>state</code>).
        Важно, чтобы вы понимали различие между ними, в противном случае просмотрите документацию React.
    </wg:p>

    <br/>
    <h2>2.13.4 Шаг 3: Опредеите минимальное (но полное) представление состояния UI</h2>

    <wg:p>
        Чтобы сделать UI интерактивным, вы должны иметь возможность инициировать изменения
        в своей базовой модели данных. React облегчает это, используя состояние <code>state</code>.
    </wg:p>

    <wg:p>
        Чтобы правильно создать приложение, сначала нужно подумать о минимальном наборе изменяемого
        состояния, которое требуется вашему приложению. <b>Совет здесь прост: не повторяйтесь!</b>. Выясните
        абсолютно минимальное представление состояния, которое требуется вашему приложению, и вычислите
        все остальное, что вам нужно по запросу. Например, если вы создаете список TODO, просто
        сохраняйте массив элементов TODO; не сохраняйте в состоянии отдельную переменную для размера
        списка. Вместо этого, когда вы хотите отобразить размер списка TODO, просто возьмите длину
        массива элементов TODO.
    </wg:p>

    <wg:p>
        Подумайте обо всех частях данных в нашем примере приложения. У нас есть:
    </wg:p>

    <wg:p>
        <ul>
            <li>The original list of products</li>
            <li>The search text the user has entered</li>
            <li>The value of the checkbox</li>
            <li>The filtered list of products</li>
        </ul>
    </wg:p>

    <wg:p>
        Давайте рассмотрим каждую из них и выясним, какая является состоянием.
        Просто задайте три вопроса о каждой части данных:
    </wg:p>

    <wg:p>
        <ol>
            <li>Передается ли она от родителя через <code>props</code>? Если это так, вероятно, это не состояние.</li>
            <li>Со временем она остается неизменной? Если это так, вероятно, это не состояние.</li>
            <li>Вы можете вычислить ее на основе любой другой части состояния или свойств своем
                компоненте? Если это так, это не состояние.</li>
        </ol>
    </wg:p>

    <wg:p>
        Исходный список продуктов передается как props, поэтому он не является состоянием. Текст поиска
        и чекбокс, похоже, находятся в состоянии, так как они меняются со временем и не могут быть
        вычислены из чего-либо. И, наконец, отфильтрованный список продуктов не является состоянием, потому
        что его можно вычислить, объединив исходный список продуктов с текстом поиска и значением чекбокса.
    </wg:p>

    <wg:p>Итак, наше состояние:</wg:p>

    <wg:p>
        <ul>
            <li>Текст поиска, введенный пользователем</li>
            <li>Значение чекбокса</li>
        </ul>
    </wg:p>

    <br/>
    <h2>2.13.5 Шаг 4: Определите, где должно находиться ваше состояние</h2>

    <wg:p>
        Посмотрите <wg:link href="${thinkingInReactStep4Url}">Thinking In React: Step 4</wg:link> в CodePen.
    </wg:p>

    <wg:p>
        Итак мы определили, что такое минимальный набор состояния приложения. Далее нам нужно
        определить, какой компонент владеет этим состоянием и изменяет его.
    </wg:p>

    <wg:p></wg:p>
    <wg:p></wg:p>
    <wg:p></wg:p>
    <wg:p></wg:p>
    <wg:p></wg:p>
    <wg:p></wg:p>
    <wg:p></wg:p>

</lt:layout>

<c:url var="prevPageUrl" value="components-and-props"/>
<c:url var="nextPageUrl" value="handling-events"/>
<app:page-navigate prevPageUrl="${prevPageUrl}"
                   pageStartAncor="pageStart"
                   nextPageUrl="${nextPageUrl}"/>