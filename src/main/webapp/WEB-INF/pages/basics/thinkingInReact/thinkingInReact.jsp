<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/basics/thinking-in-react" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>

<c:url var="tableMockUrl" value="https://reactjs.org/static/thinking-in-react-mock-1071fbcc9eed01fddc115b41e193ec11-4dd91.png"/>
<c:url var="separatingUIMockUrl" value="https://reactjs.org/static/thinking-in-react-components-eb8bda25806a89ebdc838813bdfa3601-82965.png"/>
<c:url var="thinkingInReactStep2Url" value="https://codepen.io/gaearon/pen/BwWzwm"/>
<c:url var="thinkingInReactStep4Url" value="https://codepen.io/gaearon/pen/qPrNQZ"/>
<c:url var="thinkingInReactStep5Url" value="https://codepen.io/gaearon/pen/LzWZvb"/>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page thinking-in-react-page">
    <h1>2.13 Мышление в React</h1>

    <wg:p>React - это, по мнению разработчиков, образцовый путь создания больших,
        быстрых веб-приложений с помощью JavaScript. React очень хорошо масштабируется
        для их нужд в Facebook и Instagram.</wg:p>

    <wg:p>
        Одна из многих замечательных частей React - это то, как вы думаете о
        приложениях по мере их создания. В этом документе мы рассмотрим процесс создания
        таблицы данных продуктов с поиском, используя React.
    </wg:p>

    <br/>
    <h2>2.13.1 Начинаем с макета</h2>

    <wg:p>
        Представьте, что у нас уже есть JSON API и макет нашего дизайнера. Макет выглядит так:
    </wg:p>

    <wg:p cssClass="text-center">
        <wg:img src="${tableMockUrl}"/>
    </wg:p>

    <wg:p>Наш JSON API возвращает некоторые данные, которые выглядят так:</wg:p>

    <ce:code-example-1/>

    <br/>
    <h2>2.13.2 Шаг 1: Разбиение UI на иерархию компонентов</h2>

    <wg:p>
        Первое, что вам нужно сделать, это нарисовать прямоугольники вокруг каждого
        компонента (и подкомпонента) в макете и дать им всем имена. Если вы работаете с дизайнерами, они,
        возможно, уже сделали это, поэтому поговорите с ними! Имена их слоев в Photoshop могут оказаться
        именами ваших компонентов React!
    </wg:p>

    <wg:p>
        Но как вы поймете, каков должен быть компонент? Просто используйте те же самые методы для
        принятия решения, как если бы вам было необходимо создать новую функцию или объект. Одним из таких
        методов является принцип единой ответственности, то есть в идеале компонент должен делать
        только что-то одно. Если компонент слишком разрастается, он должен быть разбит на
        меньшие подкомпоненты.
    </wg:p>

    <wg:p>
        Поскольку вы часто показываете модель данных JSON для пользователя, вы обнаружите,
        что если ваша модель была построена правильно, ваш UI (и, следовательно, структура вашего
        компонента) будет отображаться корректно. Это связано с тем, что UI и модели данных имеют
        тенденцию придерживаться одной и той же информационной архитектуры, а это означает, что
        работа по разделению вашего UI на компоненты часто тривиальна. Просто разделите его на
        компоненты, которые представляют собой ровно одну часть вашей модели данных.
    </wg:p>

    <wg:p cssClass="text-center">
        <wg:img src="${separatingUIMockUrl}"/>
    </wg:p>

    <wg:p>
        Здесь видно, что в нашем простом приложении у нас есть пять компонентов. Мы выделим
        курсивом данные, представляемые каждым компонентом.
    </wg:p>

    <wg:p>
        <ul>
            <li><code>FilterableProductTable</code> (<span style="color: orange">оранжевый</span>): содержит контент примера.</li>
            <li><code>SearchBar</code> (<span style="color: blue">голубой</span>): принимает весь пользовательский ввод.</li>
            <li><code>ProductTable</code> (<span style="color: green">зеленый</span>): отображает и фильтрует коллекцию данных, основанную на пользовательском вводе.</li>
            <li><code>ProductCategoryRow</code> (<span style="color: aqua">бирюзовый</span>): отображает заголовок каждой категории.</li>
            <li><code>ProductRow</code> (<span style="color: red">красный</span>): отображает строку каждого продукта.</li>
        </ul>
    </wg:p>

    <wg:p>
        Если вы посмотрите на <code>ProductTable</code>, вы увидите, что заголовок таблицы (содержащий надписи «Name» и
        «Price») сам по себе не является компонентом. Это вопрос предпочтения, так что можно реализовать любым способом. В этом примере мы оставили его как часть <code>ProductTable</code>, потому что он
        является частью процесса отрисовки коллекции данных, что является ответственностью <code>ProductTable</code>.
        Однако, если этот заголовок становится сложным (т. е. если мы будем добавлять возможности для
        сортировки), было бы разумно сделать его отдельным компонентом <code>ProductTableHeader</code>.
    </wg:p>

    <wg:p>
        Теперь, когда мы определили компоненты в нашем макете, давайте организуем их в иерархию.
        Это легко. Компоненты, которые расположены в другом компоненте в макете, должны
        отображаться как дочерние в иерархии:
    </wg:p>

    <wg:p>
        <ul>
            <li>
                <code>FilterableProductTable</code>
                <ul>
                    <li><code>SearchBar</code></li>
                    <li>
                        <code>ProductTable</code>
                        <ul>
                            <li><code>ProductCategoryRow</code></li>
                            <li><code>ProductRow</code></li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </wg:p>

    <br/>
    <h2>2.13.3 Шаг 2: Построение статической версии в React</h2>

    <wg:p>
        Посмотрите <wg:link href="${thinkingInReactStep2Url}">Мышление в React: Шаг 2</wg:link> в CodePen.
    </wg:p>

    <wg:p>
        Теперь, когда у вас есть иерархия компонентов, пришло время реализовать ваше приложение.
        Самый простой способ - создать версию, которая берет вашу модель данных и отрисовывает UI, но
        не имеет интерактивности. Лучше всего отделить эти процессы, потому что для создания статической
        версии требуется больше кодировать и меньше думать, в то время как для добавления интерактивности
        требуется больше мыслительного процесса, но меньше печатной рутины. Посмотрим почему.
    </wg:p>

    <wg:p>
        Чтобы создать статическую версию вашего приложения, которое отображает вашу модель данных,
        вы захотите создать компоненты, которые повторно используют другие компоненты и
        передают данные с помощью <code>props</code>. <code>props</code> - это способ передачи данных от родителя потомку.
        Если вы знакомы с концепцией состояния, <b>не используйте состояние вообще</b> для создания этой
        статической версии. Состояние зарезервировано только для интерактивности, то есть данные изменяются с течением времени.
        Поскольку это статическая версия приложения, вам это не нужно.
    </wg:p>

    <wg:p>
        Вы можете начать создавать компоненты сверху вниз или снизу вверх. То есть вы можете начать с построения компонентов,
        находящихся выше в иерархии (то есть с <code>FilterableProductTable</code>) или с более нижних
        (<code>ProductRow</code>). В более простых примерах, как правило, легче идти сверху вниз, а в более крупных проектах
        легче идти снизу вверх и писать тесты по мере создания компонентов.
    </wg:p>

    <wg:p>
        В конце этого шага вы будете иметь библиотеку повторно используемых компонентов, которые
        отображают вашу модель данных. Компоненты будут иметь только методы <code>render()</code>, поскольку
        это статическая версия вашего приложения. Компонент на вершине иерархии (<code>FilterableProductTable</code>)
        будет принимать вашу модель данных через <code>props</code>. Если вы внесете изменения в свою базовую модель
        данных и снова вызовете <code>ReactDOM.render()</code>, UI будет обновлен. Легко понять, как обновляется
        ваш UI и где вносить изменения, так как тут нет ничего сложного. <b>Односторонний поток данных</b>
        React (также называемый <b>односторонней привязкой</b>) сохраняет все модульным и быстрым.
    </wg:p>

    <br/>
    <h3>2.13.3.1 Краткая интерлюдия: Props vs State</h3>

    <wg:p>
        Существует два типа "модельных" данных в React: свойства (<code>props</code>) и состояние (<code>state</code>).
        Важно, чтобы вы понимали различие между ними, в противном случае просмотрите документацию React.
    </wg:p>

    <br/>
    <h2>2.13.4 Шаг 3: Определите минимальное (но полное) представление состояния UI</h2>

    <wg:p>
        Чтобы сделать UI интерактивным, вы должны иметь возможность инициировать изменения
        в своей базовой модели данных. React облегчает это, используя состояние <code>state</code>.
    </wg:p>

    <wg:p>
        Чтобы правильно создать приложение, сначала нужно подумать о минимальном наборе данных изменяемого
        состояния, которое требуется вашему приложению. <b>Совет здесь прост: не повторяйтесь!</b> Выясните
        абсолютно минимальное представление состояния, которое требуется вашему приложению, а все остальное,
        что вам нужно, вычисляйте. Например, если вы создаете список TODO, просто
        сохраняйте массив элементов TODO. Не сохраняйте в состоянии отдельную переменную для размера
        списка. Вместо этого, когда вы хотите отобразить размер списка, просто возьмите длину
        массива его элементов.
    </wg:p>

    <wg:p>
        Необходимо подумать обо всех частях данных в нашем примере приложения. У нас есть:
    </wg:p>

    <wg:p>
        <ul>
            <li>Оригинальный список продуктов.</li>
            <li>Текст поиска, введенный пользователем.</li>
            <li>Значение чекбокса.</li>
            <li>Отфильтрованный список продуктов.</li>
        </ul>
    </wg:p>

    <wg:p>
        Давайте рассмотрим каждую из них и выясним, какая является состоянием.
        Просто задайте три вопроса о каждой части данных:
    </wg:p>

    <wg:p>
        <ol>
            <li>Передается ли она от родителя через <code>props</code>? Если это так, вероятно, это не состояние.</li>
            <li>Со временем она остается неизменной? Если это так, вероятно, это не состояние.</li>
            <li>Вы можете вычислить ее на основании любой другой части состояния или свойств в своем
                компоненте? Если это так, это не состояние.</li>
        </ol>
    </wg:p>

    <wg:p>
        Исходный список продуктов передается как <code>props</code>, поэтому он не является состоянием. Текст поиска
        и чекбокс, похоже, находятся в состоянии, так как они меняются со временем и не могут быть
        вычислены из чего-либо. И, наконец, отфильтрованный список продуктов не является состоянием, потому
        что его можно вычислить, использовав исходный список продуктов с текстом поиска и значением чекбокса.
    </wg:p>

    <wg:p><b>Итак, наше состояние:</b></wg:p>

    <wg:p>
        <ul>
            <li>Текст поиска, введенный пользователем</li>
            <li>Значение чекбокса</li>
        </ul>
    </wg:p>

    <br/>
    <h2>2.13.5 Шаг 4: Определите, где должно находиться ваше состояние</h2>

    <wg:p>
        Посмотрите <wg:link href="${thinkingInReactStep4Url}">Мышление в React: Шаг 4</wg:link> в CodePen.
    </wg:p>

    <wg:p>
        Итак мы определили, что такое минимальный набор состояния приложения. Далее нам нужно
        определить, какой компонент владеет этим состоянием и изменяет его.
    </wg:p>

    <wg:p>
        Помните: React предоставляет односторонний поток данных по иерархии компонентов.
        Может быть сразу не понятно, какой компонент каким состоянием должен владеть. Часто
        это основная трудность у новичков, поэтому выполните следующие шаги, чтобы получить
        полное понимание:
    </wg:p>

    <wg:p>
        Для каждой части состояния в вашем приложении:
    </wg:p>

    <wg:p>
        <ul>
            <li>
                Определите каждый компонент, который отображает что-то на основе состояния.
            </li>
            <li>
                Найдите общий компонент-владелец (единственный компонент, расположенный выше всех компонентов в
                иерархии, которым требуется состояние).
            </li>
            <li>
                Состоянием должен обладать либо общий компонент-владелец, либо компонент, находящийся выше в иерархии.
            </li>
            <li>
                Если вы не можете найти компонент, который имеет смысл наделить состоянием, просто создайте новый
                компонент для хранения состояния и добавьте его в иерархию где-нибудь выше общего компонента-владельца.
            </li>
        </ul>
    </wg:p>

    <wg:p>Давайте применим эту стратегию для нашего приложения:</wg:p>

    <wg:p>
        <ul>
            <li>
                <code>ProductTable</code> должен фильтровать список продуктов на основе состояния, а <code>SearchBar</code>
                должен отображать текст поиска и состояние чекбокса.
            </li>
            <li>
                Общим компонентом-владельцем является <code>FilterableProductTable</code>.
            </li>
            <li>
                Концептуально тексту фильтра и значению чекбокса имеет смысл находиться в <code>FilterableProductTable</code>
            </li>
        </ul>
    </wg:p>

    <wg:p>
        Итак мы решили, что наше состояние будет жить в <code>FilterableProductTable</code> компоненте.
        Во-первых, добавьте свойство экземпляра <code>this.state = {filterText: '', inStockOnly: false}</code> в
        конструктор <code>FilterableProductTable</code>, чтобы отразить начальное состояние вашего приложения. Затем
        передайте <code>filterText</code> и <code>inStockOnly</code> в <code>ProductTable</code> и
        <code>SearchBar</code> в качестве <code>props</code>. Наконец, используйте
        <code>props</code> для фильтрации строк в <code>ProductTable</code> и установите значения
        полей формы в <code>SearchBar</code>.
    </wg:p>

    <wg:p>
        Вы можете посмотреть, как будет вести себя ваше приложение: установите
        <code>filterText</code> в <code>"ball"</code> и обновите приложение. Вы увидите, что таблица
        данных обновлена правильно.
    </wg:p>

    <br/>
    <h2>2.13.6 Шаг 5: Добавьте обратный поток данных</h2>

    <wg:p>
        Посмотрите <wg:link href="${thinkingInReactStep5Url}">Мышление в React: Шаг 5</wg:link> в CodePen.
    </wg:p>

    <wg:p>
        До сих пор мы создавали приложение, как функцию свойств <code>props</code> и состояния <code>state</code>,
        стекающих вниз по иерархии. Теперь пришло время организовать поток данных в обратную сторону:
        компонентам формы в глубине иерархии необходимо обновить состояние в <code>FilterableProductTable</code>.
    </wg:p>

    <wg:p>
        React делает этот поток данных явным, чтобы было легче понять, как работает ваша программа,
        но для этого требуется немного больше кода, чем в традиционной двусторонней привязке данных.
    </wg:p>

    <wg:p>
        Если вы попытаетесь ввести текст или установить флажок в текущей версии примера,
        вы увидите, что React проигнорирует ваш ввод. Это преднамеренно, так как мы установили,
        чтобы свойство <code>value</code> элемента <code>input</code> всегда было равно значению из состояния <code>state</code>,
        переданному из <code>FilterableProductTable</code>.
    </wg:p>

    <wg:p>
        Давайте подумаем о том, что мы хотим получить. Мы хотим убедиться, что всякий раз,
        когда пользователь изменяет форму, мы обновляем состояние, чтобы отображать
        ввод пользователя. Поскольку компоненты должны обновлять только собственное состояние,
        <code>FilterableProductTable</code> будет передавать коллбэки в <code>SearchBar</code>, которые будут срабатывать
        при каждом обновлении состояния. Мы можем использовать событие <code>onChange</code> на элементах
        <code>input</code>, чтобы получать уведомление об этом. Коллбэки, переданные компонентом
        <code>FilterableProductTable</code>, вызовут <code>setState()</code>, и приложение будет обновлено.
    </wg:p>

    <wg:p>
        Звучит сложно, но на самом деле это всего лишь несколько строк кода, и вам всегда
        действительно ясно, как ваши данные текут во всем приложении.
    </wg:p>

    <br/>
    <h2>2.13.7 Вот и всё</h2>

    <wg:p>
        Разработчики надеются, что эта информация даст вам представление о том, каким образом думать во время создания
        компонентов и приложений с помощью React. Хотя может потребоваться немного больше кодирования,
        чем вы привыкли, помните, что код читается гораздо больше, чем пишется. Очень легко прочитать
        этот модульный, ясный код. Когда вы начнете создавать большие библиотеки компонентов, вы оцените
        эту ясность и модульность, а с повторным использованием кода ваш собственный код начнёт сокращаться. :)
    </wg:p>
</lt:layout>

<c:url var="prevPageUrl" value="components-and-props"/>
<c:url var="nextPageUrl" value="handling-events"/>
<app:page-navigate prevPageUrl="${prevPageUrl}"
                   pageStartAncor="pageStart"
                   nextPageUrl="${nextPageUrl}"/>